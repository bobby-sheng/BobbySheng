[{"content":"背景 当前公司研发流程均在jira项目管理平台流转，每2周一个Sprint冲刺，Jira中不带具体的数据统计与人员在此Sprint中的完成度，每次Sprint冲刺结束后无法直观的看到人员的投入产出比，于是就想做一个Jira数据收集。由于公司通讯主要使用飞书，就结合了飞书卡片通知发送消息给到研发群组，供大家对上一个Sprint的投入产出与完成的工单量进行一个复盘。\n需求分析 收集当前活跃的Sprint冲刺下的所有工单 统计工单数量，并且统计工单类型 统计人员负责完成与未完成工单数量与百分比 使用飞书机器人发送飞书卡片消息给到群组 需求调研 Jira收集数据方法 在python中可以使用JIRA第三方库对Jira进行操作，通过GPT我们可知道JIRA的可操作情况\n通过回答我们可知道是可以操作Sprint管理，熟悉JIRA这个包的知道，Sprint管理是可以获取到当前Sprint所有工单的key，通过key可以获取到这个工单的详情信息，有负责人、工单类型、优先级等数据。\n如何发送飞书卡片消息 通过飞书应用机器人可调用飞书开发API发送消息接口，此接口可发送消息卡片类型的数据。消息卡片的数据需要在飞书消息卡片搭建中自行搭建，然后复制出卡片源代码给到消息接口发送即可\n飞书卡片搭建地址：https://open.feishu.cn/cardkit\n飞书发送消息API：https://open.feishu.cn/document/ukTMukTMukTM/uYzM3QjL2MzN04iNzcDN/send-message-card/send-messages-using-card-json-data\n流程简介 通过python获取jira中需要的数据，通过python填充到卡片源代码，调用飞书发送消息接口，发送消息\n实现步骤 jira数据收集 jira登录 | jira_clent.py from jira import JIRA from units.get_config_data import get_config_yaml_data import jsonpath def get_jira_client(): json_data = get_config_yaml_data() server = jsonpath.jsonpath(json_data, \u0026#34;$.jira.url\u0026#34;)[0] username = jsonpath.jsonpath(json_data, \u0026#34;$.jira.username\u0026#34;)[0] password = jsonpath.jsonpath(json_data, \u0026#34;$.jira.password\u0026#34;)[0] jira_cline = JIRA(server=server, basic_auth=(username, password)) return jira_cline if __name__ == \u0026#39;__main__\u0026#39;: print(get_jira_client().search_issues( \u0026#39;project = INET AND issuetype = 故障 AND status in (\u0026#34;To Do\u0026#34;, 开发中) AND assignee in (awen.cheng)\u0026#39;, maxResults=-1)) 获取当前项目活跃的Sprint | jira_sprint_msg.py #!/usr/bin/env python3.10.6 # -*- coding: utf-8 -*- # Author: Bobby Sheng \u0026lt;Bobby@sky-cloud.net\u0026gt; import jsonpath import copy from units.get_config_data import get_config_yaml_data from units.jira_clent import get_jira_client from units.log_control import INFO, ERROR PROJECT_KEY = \u0026#39;INET\u0026#39; EXCLUDED_SPRINT_ID = 61 def get_user_id(name_data): receive_id_data = jsonpath.jsonpath(get_config_yaml_data(), \u0026#34;$.userInfo\u0026#34;)[0] receive_id = [i.get(\u0026#34;user_id\u0026#34;) for i in receive_id_data if str(i.get(\u0026#34;username\u0026#34;)) == str(name_data)][0] return receive_id def get_sprint_issues(project_key: str): \u0026#34;\u0026#34;\u0026#34; 获取项目下活跃的sprint :param project_key: 项目key :return: 活跃sprint的ID，如果没有找到则返回None \u0026#34;\u0026#34;\u0026#34; try: boards = get_jira_client().boards(projectKeyOrID=project_key) except Exception as e: ERROR.logger.error(f\u0026#34;获取boards时发生错误: {e}\u0026#34;) return None board_id = boards[0].id if boards else None if board_id: try: active_sprints = get_jira_client().sprints(board_id, state=\u0026#39;active\u0026#39;) except Exception as e: ERROR.logger.error(f\u0026#34;获取sprints时发生错误: {e}\u0026#34;) return None if not active_sprints: ERROR.logger.error(\u0026#34;没有找到活跃的sprint。\u0026#34;) return None for sprint in active_sprints: if sprint.state == \u0026#34;ACTIVE\u0026#34; and sprint.id != EXCLUDED_SPRINT_ID: return sprint.id, sprint.name else: ERROR.logger.error(\u0026#34;没有找到符合条件的活跃sprint。\u0026#34;) return None def get_backlog_issues(project_key: str): \u0026#34;\u0026#34;\u0026#34; 获取项目下指定sprint的backlog issues :param project_key: 项目key :return: \u0026#34;\u0026#34;\u0026#34; sprint_info_list = [] try: sprint_id, sprint_name = get_sprint_issues(project_key) if not sprint_id: ERROR.logger.error(\u0026#34;无法获取sprint ID。\u0026#34;) return # 验证project_key和sprint_id的格式，这里假设它们都是符合一定规则的字符串 # 这个验证可以根据实际情况调整 if not isinstance(project_key, str) or not isinstance(sprint_id, int): ERROR.logger.error(\u0026#34;项目键或sprint ID格式不正确。\u0026#34;) return jql_str = f\u0026#39;project = {project_key} AND Sprint = {sprint_id} ORDER BY created DESC, 等级 ASC\u0026#39; backlog_issues = get_jira_client().search_issues(jql_str, maxResults=1000) count = 1 for issue in backlog_issues: sprint_info = print_issue_info(issue) sprint_info_list.append(sprint_info) count += 1 INFO.logger.info(f\u0026#34;共打印了 {count} 个事务。\u0026#34;) return sprint_info_list, sprint_name except Exception as e: ERROR.logger.error(f\u0026#34;获取backlog issues时发生错误: {e}\u0026#34;) def print_issue_info(issue): \u0026#34;\u0026#34;\u0026#34; 打印issue信息 \u0026#34;\u0026#34;\u0026#34; sprint_info_data = { \u0026#34;key\u0026#34;: issue.key, \u0026#34;issue_type\u0026#34;: issue.fields.issuetype, \u0026#34;summary\u0026#34;: issue.fields.summary, \u0026#34;assignee\u0026#34;: issue.fields.assignee, \u0026#34;reporter\u0026#34;: issue.fields.reporter, \u0026#34;priority\u0026#34;: issue.fields.priority, \u0026#34;status\u0026#34;: issue.fields.status, \u0026#34;customfield_10106\u0026#34;: issue.fields.customfield_10106, } return sprint_info_data def job_completion_rate(sprint_info_list: list): if not isinstance(sprint_info_list, list): raise ValueError(\u0026#34;输入参数必须是一个列表\u0026#34;) story_list, story_list_done, story_list_fail = [], [], [] task_list, task_list_done, task_list_fail = [], [], [] bug_list, bug_list_done, bug_list_fail = [], [], [] completed_statuses = {\u0026#34;完成\u0026#34;, \u0026#34;测试中\u0026#34;, \u0026#34;暂不处理\u0026#34;, \u0026#34;测试通过\u0026#34;} INFO.logger.info(f\u0026#34;正在获取项目的sprint type信息...\u0026#34;) for i in sprint_info_list: if str(i.get(\u0026#34;issue_type\u0026#34;)) == \u0026#34;故事\u0026#34;: story_list.append(i) if str(i.get(\u0026#34;status\u0026#34;)) in completed_statuses: story_list_done.append(i) else: story_list_fail.append(i) elif str(i.get(\u0026#34;issue_type\u0026#34;)) == \u0026#34;子任务\u0026#34;: task_list.append(i) if str(i.get(\u0026#34;status\u0026#34;)) in completed_statuses: task_list_done.append(i) else: task_list_fail.append(i) else: bug_list.append(i) if str(i.get(\u0026#34;status\u0026#34;)) in completed_statuses: bug_list_done.append(i) else: bug_list_fail.append(i) all_done = len(bug_list_done) + len(task_list_done) + len(story_list_done) completion_rate = { \u0026#34;len_story\u0026#34;: len(story_list), \u0026#34;len_task\u0026#34;: len(task_list), \u0026#34;len_bug\u0026#34;: len(bug_list), \u0026#34;len_all\u0026#34;: len(sprint_info_list), \u0026#34;story_handle\u0026#34;: { \u0026#34;done\u0026#34;: len(story_list_done), \u0026#34;fail\u0026#34;: len(story_list_fail), \u0026#34;rate\u0026#34;: round((len(story_list_done) / len(story_list)) * 100, 2) }, \u0026#34;task_handle\u0026#34;: { \u0026#34;done\u0026#34;: len(task_list_done), \u0026#34;fail\u0026#34;: len(task_list_fail), \u0026#34;rate\u0026#34;: round((len(task_list_done) / len(task_list)) * 100, 2) }, \u0026#34;bug_handle\u0026#34;: { \u0026#34;done\u0026#34;: len(bug_list_done), \u0026#34;fail\u0026#34;: len(bug_list_fail), \u0026#34;rate\u0026#34;: round((len(bug_list_done) / len(bug_list)) * 100, 2) }, \u0026#34;all_handle\u0026#34;: { \u0026#34;done\u0026#34;: all_done, \u0026#34;fail\u0026#34;: len(bug_list_fail) + len(task_list_fail) + len(story_list_fail), \u0026#34;rate\u0026#34;: round((all_done / len(sprint_info_list)) * 100, 2) } } return completion_rate def user_msg_data(sprint_info_list: list): \u0026#34;\u0026#34;\u0026#34; 人员的数据统计，返回卡片的json数据 :param sprint_info_list: 包含任务信息的列表，每个元素是字典类型 \u0026#34;\u0026#34;\u0026#34; if not isinstance(sprint_info_list, list): raise ValueError(\u0026#34;输入参数必须是一个列表\u0026#34;) if not all(isinstance(item, dict) for item in sprint_info_list): raise ValueError(\u0026#34;列表中的每个元素都必须是一个字典\u0026#34;) data_msg = {卡片中一列的代码，我这里做的是循环填充生成的} #TODO issue_types = [\u0026#39;故事\u0026#39;, \u0026#39;故障\u0026#39;, \u0026#39;子任务\u0026#39;, \u0026#39;任务\u0026#39;, \u0026#39;故事点\u0026#39;] issue_status = [\u0026#34;完成\u0026#34;, \u0026#34;测试中\u0026#34;, \u0026#34;暂不处理\u0026#34;, \u0026#34;测试通过\u0026#34;, \u0026#34;待办\u0026#34;, \u0026#34;产品验收中\u0026#34;, \u0026#34;开发中\u0026#34;] done_status = {\u0026#34;完成\u0026#34;, \u0026#34;测试中\u0026#34;, \u0026#34;暂不处理\u0026#34;, \u0026#34;测试通过\u0026#34;, \u0026#34;产品验收中\u0026#34;} issue_types_dones = [\u0026#39;故事完成数\u0026#39;, \u0026#39;故障完成数\u0026#39;, \u0026#39;子任务完成数\u0026#39;, \u0026#39;任务完成数\u0026#39;] type_counts = {t: 0 for t in issue_types} # 初始化计数 status_counts = {t: 0 for t in issue_status} # 初始化计数 issue_types_counts = {t: 0 for t in issue_types_dones} # 初始化计数 user_counts = {} data_msg_list = [] for user_data in sprint_info_list: assignee = user_data.get(\u0026#34;assignee\u0026#34;) if assignee is not None: if assignee not in user_counts: user_counts[assignee] = {\u0026#39;total\u0026#39;: 0, **type_counts, **status_counts, **issue_types_counts} user_counts[assignee][\u0026#39;total\u0026#39;] += 1 if user_data.get(\u0026#39;customfield_10106\u0026#39;): user_counts[assignee][\u0026#39;故事点\u0026#39;] += float(user_data.get(\u0026#39;customfield_10106\u0026#39;)) for issue_type in issue_types: if str(user_data.get(\u0026#39;issue_type\u0026#39;)) == issue_type: user_counts[assignee][issue_type] += 1 for issue_statu in issue_status: if str(user_data.get(\u0026#39;status\u0026#39;)) == issue_statu: user_counts[assignee][issue_statu] += 1 for issue_types_done in issue_types_dones: issue_type_str = issue_types_done[:-3] if str(user_data.get(\u0026#39;issue_type\u0026#39;)) == issue_type_str and str(user_data.get(\u0026#39;status\u0026#39;)) in done_status: user_counts[assignee][issue_types_done] += 1 else: ERROR.logger.error(\u0026#34;assignee字段为空\u0026#34;) # 输出结果 one {\u0026#39;total\u0026#39;: 22, \u0026#39;故事\u0026#39;: 6, \u0026#39;故障\u0026#39;: 6, \u0026#39;子任务\u0026#39;: 10} for data_key, data_value in user_counts.items(): count = 0 for k, v in data_value.items(): if k in done_status: count += v # print(data_key, data_value, count) task_num = int(data_value.get(\u0026#39;任务\u0026#39;)) + int(data_value.get(\u0026#39;子任务\u0026#39;)) done_task_num = int(data_value.get(\u0026#39;子任务完成数\u0026#39;)) + int(data_value.get(\u0026#39;任务完成数\u0026#39;)) userid = get_user_id(data_key) data_msg_copy = copy.deepcopy(data_msg) data_msg_copy[\u0026#34;columns\u0026#34;][0][\u0026#34;elements\u0026#34;][0][\u0026#34;persons\u0026#34;][0][\u0026#34;id\u0026#34;] = userid data_msg_copy[\u0026#34;columns\u0026#34;][1][\u0026#34;elements\u0026#34;][0][\u0026#34;columns\u0026#34;][0][\u0026#34;elements\u0026#34;][0][\u0026#34;text\u0026#34;][ \u0026#34;content\u0026#34;] = f\u0026#34;{data_value.get(\u0026#39;故事完成数\u0026#39;)}/{data_value.get(\u0026#39;故事\u0026#39;)}个\u0026#34; data_msg_copy[\u0026#34;columns\u0026#34;][2][\u0026#34;elements\u0026#34;][0][\u0026#34;columns\u0026#34;][0][\u0026#34;elements\u0026#34;][0][\u0026#34;text\u0026#34;][ \u0026#34;content\u0026#34;] = f\u0026#34;{done_task_num}/{task_num}个\u0026#34; data_msg_copy[\u0026#34;columns\u0026#34;][3][\u0026#34;elements\u0026#34;][0][\u0026#34;columns\u0026#34;][0][\u0026#34;elements\u0026#34;][0][\u0026#34;text\u0026#34;][ \u0026#34;content\u0026#34;] = f\u0026#34;{data_value.get(\u0026#39;故障完成数\u0026#39;)}/{data_value.get(\u0026#39;故障\u0026#39;)}个\u0026#34; data_msg_copy[\u0026#34;columns\u0026#34;][4][\u0026#34;elements\u0026#34;][0][\u0026#34;columns\u0026#34;][0][\u0026#34;elements\u0026#34;][0][\u0026#34;text\u0026#34;][ \u0026#34;content\u0026#34;] = f\u0026#34;{data_value.get(\u0026#39;故事点\u0026#39;)}个\u0026#34; data_msg_copy[\u0026#34;columns\u0026#34;][5][\u0026#34;elements\u0026#34;][0][ \u0026#34;content\u0026#34;] = f\u0026#34;({int(count)}/{int(data_value.get(\u0026#39;total\u0026#39;))}) \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;{round((int(count) / int(data_value.get(\u0026#39;total\u0026#39;))) * 100, 2)}%\u0026lt;/font\u0026gt;\u0026#34; data_msg_list.append(data_msg_copy) return data_msg_list 飞书API发送 飞书API认证 #!/usr/bin/env python3.10.6 # -*- coding: utf-8 -*- # Author: Bobby Sheng \u0026lt;Bobby@sky-cloud.net\u0026gt; from units.get_config_data import get_config_yaml_data import requests import jsonpath Config = get_config_yaml_data() def tenant_access_token(): \u0026#34;\u0026#34;\u0026#34;获取引用tenant_access_token :return: tenant_access_token \u0026#34;\u0026#34;\u0026#34; data = {\u0026#34;app_id\u0026#34;: jsonpath.jsonpath(Config, \u0026#34;$.feishu.app_id\u0026#34;)[0], \u0026#34;app_secret\u0026#34;: jsonpath.jsonpath(Config, \u0026#34;$.feishu.app_secret\u0026#34;)[0]} res = requests.post(jsonpath.jsonpath(Config, \u0026#34;$.feishu.webhook_token\u0026#34;)[0], data=data).json() headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Authorization\u0026#39;: \u0026#34;Bearer \u0026#34; + res[\u0026#34;app_access_token\u0026#34;] } return headers 飞书卡片消息发送 #!/usr/bin/env python3.10.6 # -*- coding: utf-8 -*- # Author: Bobby Sheng \u0026lt;Bobby@sky-cloud.net\u0026gt; import requests import json import time import jsonpath from units.get_config_data import get_config_yaml_data from units.log_control import INFO from feushu_api.feishu_login import tenant_access_token from jira_business.jira_sprint_msg import user_msg_data, get_backlog_issues, job_completion_rate data_msg = {卡片源代码} #TODO # ${sprint} ${ALL} ${story_all} ${bug_all} ${task_all} ${story_fail} ${story_done} ${story_rate} ${bug_fail} ${bug_done} ${bug_rate} # ${task_fail} ${task_done} ${task_rate} ${all_fail} ${all_done} ${all_rate} def send_sprint_msg(): sprint_info_list, sprint_name = get_backlog_issues(\u0026#39;INET\u0026#39;) # # 开发者数据统计 data_msg_list = user_msg_data(sprint_info_list) c.get(\u0026#34;i18n_elements\u0026#34;).get(\u0026#39;zh_cn\u0026#39;).extend(data_msg_list) # 工单数据统计 job_data = job_completion_rate(sprint_info_list) c1 = json.dumps(c).replace(\u0026#34;${sprint}\u0026#34;, sprint_name).replace(\u0026#34;${ALL}\u0026#34;, str(job_data[\u0026#34;len_all\u0026#34;])).replace( \u0026#34;${story_all}\u0026#34;, str(job_data[ \u0026#34;len_story\u0026#34;])) \\ .replace(\u0026#34;${bug_all}\u0026#34;, str(job_data[\u0026#34;len_bug\u0026#34;])).replace(\u0026#34;${task_all}\u0026#34;, str(job_data[\u0026#34;len_task\u0026#34;])). \\ replace(\u0026#34;${story_fail}\u0026#34;, str(job_data[\u0026#34;story_handle\u0026#34;][\u0026#34;fail\u0026#34;])).replace(\u0026#34;${story_done}\u0026#34;, str(job_data[\u0026#34;story_handle\u0026#34;][\u0026#34;done\u0026#34;])). \\ replace(\u0026#34;${story_rate}\u0026#34;, str(job_data[\u0026#34;story_handle\u0026#34;][\u0026#34;rate\u0026#34;])).replace(\u0026#34;${bug_fail}\u0026#34;, str(job_data[\u0026#34;bug_handle\u0026#34;][\u0026#34;fail\u0026#34;])). \\ replace(\u0026#34;${bug_done}\u0026#34;, str(job_data[\u0026#34;bug_handle\u0026#34;][\u0026#34;done\u0026#34;])).replace(\u0026#34;${bug_rate}\u0026#34;, str(job_data[\u0026#34;bug_handle\u0026#34;][\u0026#34;rate\u0026#34;])). \\ replace(\u0026#34;${task_fail}\u0026#34;, str(job_data[\u0026#34;task_handle\u0026#34;][\u0026#34;fail\u0026#34;])).replace(\u0026#34;${task_done}\u0026#34;, str(job_data[\u0026#34;task_handle\u0026#34;][\u0026#34;done\u0026#34;])). \\ replace(\u0026#34;${task_rate}\u0026#34;, str(job_data[\u0026#34;task_handle\u0026#34;][\u0026#34;rate\u0026#34;])).replace(\u0026#34;${all_fail}\u0026#34;, str(job_data[\u0026#34;all_handle\u0026#34;][\u0026#34;fail\u0026#34;])). \\ replace(\u0026#34;${all_done}\u0026#34;, str(job_data[\u0026#34;all_handle\u0026#34;][\u0026#34;done\u0026#34;])).replace(\u0026#34;${all_rate}\u0026#34;, str(job_data[\u0026#34;all_handle\u0026#34;][\u0026#34;rate\u0026#34;])) headers = tenant_access_token() rich_text = { \u0026#34;receive_id\u0026#34;: \u0026#34;6b9eab87\u0026#34;, \u0026#34;msg_type\u0026#34;: \u0026#34;interactive\u0026#34;, \u0026#34;content\u0026#34;: c1 } # oc_17703b85be608b568b1fed1c3a2f3110 测试群 # oc_672137dedd6b9104cdf1d99d5bdea47a 研发群 INFO.logger.info(f\u0026#34;消息接受者：6b9eab87\u0026#34;) post_data = json.dumps(rich_text) response = requests.post( jsonpath.jsonpath(get_config_yaml_data(), \u0026#34;$.feishu.webhook\u0026#34;)[0], headers=headers, data=post_data, verify=False ) result = response.json() INFO.logger.info(f\u0026#34;发送消息接返回{result}\u0026#34;) if result.get(\u0026#39;code\u0026#39;) != 0: time_now = time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, time.localtime(time.time())) result_msg = result[\u0026#39;errmsg\u0026#39;] if result.get(\u0026#39;errmsg\u0026#39;, False) else \u0026#39;未知异常\u0026#39; error_data = { \u0026#34;msgtype\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;text\u0026#34;: { \u0026#34;content\u0026#34;: f\u0026#34;[注意-自动通知]飞书机器人消息发送失败，时间：{time_now}，\u0026#34; f\u0026#34;原因：{result_msg}，请及时跟进，谢谢!\u0026#34; }, \u0026#34;at\u0026#34;: { \u0026#34;isAtAll\u0026#34;: False } } INFO.logger.error(\u0026#34;消息发送失败，自动通知：%s\u0026#34;, error_data) requests.post(jsonpath.jsonpath(get_config_yaml_data(), \u0026#34;$.feishu.webhook\u0026#34;)[0], headers=headers, data=json.dumps(error_data)) if __name__ == \u0026#39;__main__\u0026#39;: send_sprint_msg() 代码结构 效果展示 总结 空闲时间编写，没太多时间去构思代码设计，主要以实现功能为主，代码写的简单粗暴。更多的是提供一种思路。\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/%E9%A3%9E%E4%B9%A6+jiar%E9%9B%86%E6%88%90sprint%E6%8A%A5%E5%91%8A%E5%8D%A1%E7%89%87%E6%B6%88%E6%81%AF/","summary":"背景 当前公司研发流程均在jira项目管理平台流转，每2周一个Sprint冲刺，Jira中不带具体的数据统计与人员在此Sprint中的完成度，每次Sprint冲刺结束后无法直观的看到人员的投入产出比，于是就想做一个Jira数据收集。由于公司通讯主要使用飞书，就结合了飞书卡片通知发送","title":"飞书+jiar集成|Sprint报告卡片消息"},{"content":"背景 小程序由于其独特的属性,无法如web浏览器应用可通过浏览器开发者控制台检查js文件.无法直接进行逆向解密,于是有大佬开发出源码解密工具 wxappunpacker ,此工具可以通过在pc微信打开小程序,解密本地的小程序文档,还原出小程序的开发代码,可找到源码逻辑进行分析逆向.当然,此工具对于有的小程序可能解密也是不够彻底的,这个到时候出现了情况可寻找其他解决办法\n工具安装 安装node.js 安装 node brew install node 配置npm淘宝源 npm config set registry https://registry.npm.taobao.org npm install esprima npm install css-tree npm install cssbeautify npm install vm2 npm install uglify-es npm install js-beautify npm install escodegen 下载wxappunpacker包 微信开发者工具安装 下载地址 反编译工具安装包:链接：https://pan.baidu.com/s/1CsXCCPV5Yipdq8uR44Xf_A?pwd=ilb9 提取码：ilb9 node.js环境(建议选.msi版本无需配置环境变量)：https://nodejs.org/zh-cn/download 微信开发者工具：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 一键反编译工具(嫌反编译麻烦下这个)：链接：https://pan.baidu.com/s/12S0ZTkYAFWYfui7ujjrijw?pwd=tzuq 提取码：tzuq macos 好像也可以使用MacWXAPKGDecrypt这个工具,没试过,地址为: https://blog.csdn.net/gitblog_00073/article/details/137101334 开始解密小程序文件 找到小程序在本地保存的位置 mac的微信保存文件地址一般在: /Users/\u0026lt;UserName\u0026gt;/Library/Containers/com.tencent.xinWeChat/Data/.wxapplet/packages windows一般查看文件保存位置即可,这里使用mac开发环境学习记录 清理小程序保存文件夹,因为在pc端每次进入一个小程序在此文件夹会生成小程序的相关文件.这里为了方便定位小程序包,可以选择清理文件再出现打开小程序,更加直观的找到需要操作的小程序,也可以最后再使用手机查看该小程序的更多资料，其中就包含AppID，找到当前目录中对应的即可. 我们为了完整的获取源码，就在原来的小程序上点点点，尽可能的点点点： 找到 APP.wxapkg 的文件，这个是小程序的主文件，有一些小程序还会生成分包 使用工具解密,图片可以看到分包个数和是否成功,在文件夹会生成一个反编译后的包,还有分包的概念后续补充 获取主包和若干子包 进入wxappunpacker 安装目录,给予bingo.sh 权限 chmod 777 bingo.sh 解包主包 ./bingo.sh ../小程序包解密/__APP__.wxapkg 解包子包 ./bingo.sh testpkg/sub-1-xxx.wxapkg -s=…/master-xxx 一般来说，主包比较大，子包比较小（不绝对）.在使用上面工具的时候，使用的时候有报错，继续安装对应模块试试：npm install uglify-es 微信小程序导入解密好的包 导入解密出的包,选择测试号,不使用云服务,点击确定 问题 导入的小程序无法正常打开,提示没有app.json文件,初步判断是解密的时候未完全解密,因为我在解密的时候脚本报错了 问题待处理 https://blog.csdn.net/Liang_ming_/article/details/132787756\n此解密工具太老了,总是保存,尝试修改源码后还是会报其他错误,索引发现新的解密包unveilr,下载地址 https://u.openal.lat/#downloadList\n这个工具在mac下载下来的一个文本,不知道如何去使用,在windows倒是可执行的exe\n大部分小程序类的工具都是windows的,mac系统在国内不是很友好 总结 解密不全也无问题，主要是看需要加密的那段代码是否可以看到。并且可分析\n参考地址 mac版微信小程序反编译学习 https://blog.csdn.net/csdnmmd/article/details/132757564\n微信小程序wxappunpacker反编译 https://blog.csdn.net/weixin_45965246/article/details/132939907\nmac_wxapkg_decrypt (这是适用于mac的解密包,我还没试试,有时间再看看,我还是想看看wxappunpacker为神马会报错) https://gitcode.com/TinyNiko/mac_wxapkg_decrypt/overview?utm_source=artical_gitcode\u0026isLogin=1 探索MacWXAPKGDecrypt：解锁微信小程序包的秘密 https://blog.csdn.net/gitblog_00073/article/details/137101334 wxappUnpacker 这个包也是解密的 https://github.com/larack8/wxappUnpacker ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%85%E8%A7%A3%E7%A0%81/","summary":"背景 小程序由于其独特的属性,无法如web浏览器应用可通过浏览器开发者控制台检查js文件.无法直接进行逆向解密,于是有大佬开发出源码解密工具 wxappunpacker ,此工具可以通过在pc微信打开小程序,解密本地的小程序文档,还原出小程序的开发代码,可找到源码逻辑进行分析逆向.当然,此工具对于有的小程序可","title":"小程序包解码"},{"content":"GTM GTM：global-traffic-manager广域网流量管理 根据业务策略，数据中心状况，网络状况和应用性能来分配最终用户的应用请求，实现最高的应用性能，更短的停机时间以及更简化的管理。通过智能的响应DNS查询提供服务的一种方式。DNS的作用把域名与IP地址对应起来的一种技术。\nGTM工作场景： 用户发起请求，首先解析域名。 DNS查询到达F5 GTM/BIG-IP DNS。 GTM根据策略（如地理位置、数据中心健康状况、应用程序性能、负载）选择合适的数据中心。 GTM响应DNS查询，返回最适数据中心的IP地址。 用户的请求由DNS解析后的IP直接送达被选定的数据中心处理。 GTM应用场景 场景一：主备IP容灾 ​ 客户网站是由多个源站（或数据中心）进行服务支撑时，使用主备智能切换可以确保服务高可用。简单说，有两个IP地址A（主）和B（备），正常情况下，用户访问IP地址A、当IP地址A故障后，用户将不再访问到IP地址A，而是访问到IP地址B。\n场景二：多级备份 ​ 客户网站是由多个数据中心进行服务支撑时，根据实际情况进行备份分级，实现有线同城备份，再次异地备份。\n场景三：高并发下的****负载均衡 ​ 用户量大，或者用户突增（如年中大促、双十一、618促销等）情况下，需要对源站多个IP配置负载均衡，避免源站崩溃。通过网宿GTM，只需要配置调度策略，即可实现权重负载均衡。假设源站有多个IP地址A，B，C，D，A、B设为主源，C，D作为备源，A的性能最佳，主源A，B的负载比例可设为3:2，即A的负载为60%，B的负载为40%，当主源全部故障时，备源将启用，当主源恢复时，切回主源。\n场景四：CDN智能互备 ​ 当客户网站有使用多个CDN服务商时，通过全网融合流量分配解决方案可实现CDN之间的互备。\nDNS解析 CDN内容分发 1.用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址. 2.LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期) 3.ROOT DNS将域名授权dns记录回应给 LocalDns 4.LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址 5.域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns 6.LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址 7.智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns 8.LocalDns 将得到的域名ip地址，回应给 用户端 9.用户得到域名ip地址后，访问站点服务器 10.CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)\nLTM GTM：local-traffic-manager局域网流量管理 LTM是在进行本地流量管理，可以对服务器节点之间的流量进行管理；\n客户发出服务请求到VIP BIGIP接收到请求，将数据包中目的IP地址改为选中的后台服务器IP地址，然后将数据包发出到后台选定的服务器 后台服务器收到后，将应答包按照其路由发回到BIGIP BIGIP收到应答包后将其中的源地址改回成VIP的地址，发回客户端，由此就完成了一个标准的服务器负载均衡的流程。 2.负载均衡典型流程\n通过VIP来截获合适的需要负载均衡的流量 服务器监控和健康检查,随时了解服务器群的可用性状态 负载均衡和应用交换功能,通过各种策略导向到合适的服务器 2.1 通过VIP来截获合适的需要负载均衡的流量\n在BIGIP上通过设置VIP来截获需要进行负载均衡的流量，这个VIP地址可以是一个独立的主机地址和端口的组合（例如：202.100.1.1:80）也可以是一个网络地址和端口的组合（例如：202.100.1.0:80），当流量经过BIGIP的时候，凡是命中VIP的流量都将被截获并按照规则进行负载均衡。\n2.2 服务器的健康监控和检查\n2.3 负载均衡和应用交换功能,通过各种策略导向到合适的服务器\n基于LTM模块的基本组网模式\nF5 LTM\u0026amp;GTM\nLTM和GTM的对比 LTM是在进行本地流量管理，可以对服务器节点之间的流量进行管理；\n而GTM不参与服务器节点的具体应用分发，但是它从整个广域网层面进行数据中心或者链路之间的数据分发；\n所以在某些环节中，LTM和GTM是综合运用的，也就是从链路层面或者多中心的层面就利用GTM划分，而到了单一的应用服务器前端，我们可以用LTM进行应用分发，LTM和GTM的这种联合应用有很多种联合部署方式\n下面就为大家描述其中两种联合部署方式：\n举例：一个企业拥有北京和广州两个数据中心，每个数据中心都是在多链路的模式下，在部署F5设备的时候，就可以在每个数据中心的出口部署相对应的GTM设备，而在每个数据中心的后端，也就是在应用服务器的前端，则部署相对应的LTM设备，这样就可以通过GTM来对北京和广州两个数据中心之间的应用分发，并且同时还要对每个数据中心的多条链路之间的情况进行分发，而LTM在服务器前端，对进入到LTM设备的应用请求往各个服务节点进行分发。\nLTM、GTM单独部署的优缺点 优点：结构清晰，便于实施和扩展；LTM和GTM互不干扰。\n缺点：一次性投入较大。\nLTM、GTM整合部署\n来进行单独部署\nGTM就类似于通过dns域名解析选择合适的数据中心发送网络请求，LTM就是实际的网络走向，VS到pool等流转，可以结合使用\n个人总结： GTM与LTM均为实现负载均衡或者多服务器调度管理。GTM针对的是广域网，调度的是全国各地的数据中心，通过DNS解析规则，分发流量。LTM是局域网内通过命中vip，设备拦截后通过设置的pool 找到对应的服务器节点，再返回数据。针对不同的对象做的不同的方案。实际是差不多意思。实现不一样\n参考： f5 gtm 工作原理_GTM设备原理以及部署方式\nF5 LTM 负载均衡理论\nF5之LTM入门（转）\nF5 GTM DNS 知识点和实验 3\nF5之LTM实现流程及操作\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/f5-gtm-ltm%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF/","summary":"GTM GTM：global-traffic-manager广域网流量管理 根据业务策略，数据中心状况，网络状况和应用性能来分配最终用户的应用请求，实现最高的应用性能，更短的停机时间以及更简化的管理。通过智能的响应DNS查询提供服务的一种方式。DNS的作用把域名与IP地址对应起来的一种技","title":"F5 GTM LTM工作场景"},{"content":"async 语法 import asyncio # 带asunc开头的函数为协程函数 async def work(num): # 模拟逻辑运行时间,不懂await asyncio.sleep(1)的没事，这就是一个asyncio的等待方法 await asyncio.sleep(1) return num + 1 # async协程函数的调用 work_data = asyncio.run(work(3)) print(work_data) 运行结果为：[4, 5] 运行时间为：1 s async 函数的嵌套 import asyncio import time import aiofiles import yaml # aiofiles为异步上下文读取文件的方法 async def read_file(file_dir): async with aiofiles.open(file_dir, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: # await等待读取完成并且获取返回值给到data,如果不加await是获取不到返回值的 data = await file.read() yaml_data = yaml.load(data, Loader=yaml.FullLoader) return yaml_data # await 也可以执行异步函数，await会等待函数执行完成，会阻塞，单独await的调用函数不是协程，为串行同步任务 async def main(file_dir): # 串行同步，被await堵塞 read_data = await read_file(file_dir) read_data1 = await read_file(file_dir) # creat_task，事件循环不会堵塞 这两个是并发执行 task1 = asyncio.create_task(read_file(file_dir)) task2 = asyncio.create_task(read_file(file_dir)) read_data = await task1 read_data1 = await task2 # 协程并发,返回的是一个列表值，所有的返回都写入到列表 task = [asyncio.create_task(read_file(file_path)) for file_path in file_dir] data = await asyncio.gather(*task) return data # async协程函数的调用 t1 = time.time() work_data = asyncio.run(main(3)) print(f\u0026#34;运行结果为：{work_data}\u0026#34;) print(f\u0026#34;运行时间为：{int(time.time() - t1)} s\u0026#34;) async 不同函数异步并发使用 import asyncio import time # 带asunc开头的函数为协程函数 async def work(num): # 模拟逻辑运行时间,不懂await asyncio.sleep(1)的没事，这就是一个asyncio的等待方法 await asyncio.sleep(1) return num + 1 # 带asunc开头的函数为协程函数 async def work2(num): await asyncio.sleep(2) return num + 2 async def main(num): # 异步执行方法，asyncio.gather，把协程函数写入，这两个方法会并发执行 # 存入不同的协程对象，达到异步的效果 task = [asyncio.create_task(work(num)),asyncio.create_task(work2(num))] data = await asyncio.gather(*task) return data # async协程函数的调用 t1 = time.time() work_data = asyncio.run(main(3)) print(f\u0026#34;运行结果为：{work_data}\u0026#34;) print(f\u0026#34;运行时间为：{int(time.time() - t1)} s\u0026#34;) 运行结果为：[4, 5] 运行时间为：2 s # 安装正常执行的逻辑，应该需要执行3s,异步只拿了最后的结果 async 同函数异步并发使用 import asyncio import time # 带asunc开头的函数为协程函数 async def work(num): # 模拟逻辑运行时间,不懂await asyncio.sleep(1)的没事，这就是一个asyncio的等待方法 await asyncio.sleep(1) return num + 1 async def main(num): # 同一个协程函数，跌倒传入不同的参数，生成事件循环列表，异步并发执行。 task = [asyncio.create_task(work(i)) for i in range(num)] # 使用`create_task()`函数创建任务的方式可以同时执行多个协程函数 data = await asyncio.gather(*task) return data # async协程函数的调用 t1 = time.time() work_data = asyncio.run(main(3)) print(f\u0026#34;运行结果为：{work_data}\u0026#34;) print(f\u0026#34;运行时间为：{int(time.time() - t1)} s\u0026#34;) 运行结果为：[1, 2, 3] 运行时间为：1 s # 安装正常执行的逻辑，应该需要执行3s,因为我传入了3个值， #每个值执行等待1s，但是使用了异步方法，并发执行只需要1s aiofiles 文件写入的案例 import aiofiles import asyncio async def write_to_file(file_dir, content): async with aiofiles.open(file_dir, \u0026#39;w\u0026#39;) as file: await file.write(content) async def main(): file_dir = \u0026#39;path/to/file.txt\u0026#39; content = \u0026#39;Hello, World!\u0026#39; await write_to_file(file_dir, content) asyncio.run(main()) 并发编程参考案例 async def get_yaml_data(file_dirs): \u0026#34;\u0026#34;\u0026#34; 并发处理yaml数据并写入缓存 \u0026#34;\u0026#34;\u0026#34; # 第一步异步并发读取所有路径文件内容 read_data_list = [asyncio.create_task(read_file(file_dir)) for file_dir in file_dirs] # 第二步把获取到的文件内容，迭代传入到process_include函数，生成task事件循环协程对象列表 process_data_list = [asyncio.create_task(process_include(read_data)) for read_data in await asyncio.gather(*read_data_list)] # 第三步获取process_include返回值列表，传入异步函数case_process时间任务对象列表 case_data_list = [asyncio.create_task(CaseData().case_process(process_data, case_id_switch=True)) for process_data in await asyncio.gather(*process_data_list)] # 第四步把一样，传入时间任务函数列表，使用await asyncio.gather()并发执行 write_case_list = [asyncio.create_task(write_case_process(write_case)) for write_case in await asyncio.gather(*case_data_list)] results = await asyncio.gather(*write_case_list) return results # 执行 t1 = time.time() api_file = [] case_file = [] file_dirs = get_all_files(file_path=ensure_path_sep(\u0026#34;\\\\data\u0026#34;), yaml_data_switch=True) for i in file_dirs: if \u0026#34;\\\\data\\\\api\u0026#34; in i: api_file.append(i) else: case_file.append(i) asyncio.run(get_yaml_data(api_file)) yaml_data = asyncio.run(get_yaml_data(case_file)) print(len(_cache_config)) print(time.time() - t1) # 总结：拆分步骤，把函数需要的值设置为列表，迭代生成事件循环，并发处理。以此类推，直到完成全部逻辑 # 那么需要使用并发的函数都需使用async def 开头，await 执行并获取结果 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/asyncio%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","summary":"async 语法 import asyncio # 带asunc开头的函数为协程函数 async def work(num): # 模拟逻辑运行时间,不懂await asyncio.sleep(1)的没事，这就是一个asyncio的等待方法 await asyncio.sleep(1) return num + 1 # async协程函数的调用 work_data = asyncio.run(work(3)) print(work_data) 运行结果为：[4, 5] 运行时间为：1 s async 函数的嵌套 import asyncio import time import aiofiles import yaml # aiofi","title":"asyncio使用介绍"},{"content":"简介 flask-SQLAlchemy对sqlite数据库的连接与增删改查 flask 与sqlite的创建与连接 #参考地址 https://www.py.cn/kuangjia/flask/24552.html 单表操作 # 参考地址 https://blog.csdn.net/weixin_45618073/article/details/125137141 增加 #单个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026#34;) db.session.add(s1) db.session.commit() #除了查询，都要commit #多个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026#34;) stu2=Student(name=\u0026#34;李四\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1445\u0026#34;) stu3=Student(name=\u0026#34;王五\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1465245\u0026#34;) stu4=Student(name=\u0026#34;老王\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;145245\u0026#34;) db.session.add_all([stu,stu2,stu3,stu4]) db.session.commit() #除了查询，都要commit 查询 #单个数据查询id为1的数据表，返回一个对象 stu=Student.query.get(1) print(Student.name) #查询表中所有数据，返回一个列表，值为数据对象 stu=Student.query.all() for i in stu: print(Student.name) #打印表所有此字段值 #(类名.属性名 条件操作符 条件) 过滤特定条件,返回的是query对象 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first() #后面可以接.all() 表示取全部，.first() 表示取第一个值 for i in stu: print(表.列) #打印列表中数据所有此字段值 #(关键字参数对) 单条件查询,条件必须关键字参数,而且and连接 Student.query.filter_by(id=\u0026#34;1\u0026#34;).first() #后面可以接.all() 表示取全部，.first() 表示取第一个值，还可以继续接条件.filter(列=值)，或者.delete for i in stu: print(Student.name) #打印列表中数据所有此字段值 修改 #第一种，直接拼接在查询后面 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first().update({\u0026#34;列\u0026#34;:\u0026#34;值\u0026#34;}) print(stu) #返回修改了多少条数据的数量 db.session.commit() #除了查询，都要commit #第二种 改单个 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first() stu.列=新值 #直接赋予新值 db.session.add(s1) #修改值的需要增加add方法 db.session.commit() #除了查询，都要commit #第二种 循环改多个 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).all() for i in stu: i.列=新值 #直接赋予新值 db.session.add(s1) db.session.commit() #除了查询，都要commit 删除 #第一种，直接拼接在查询后面 stu=表名.query.filter(列=值).delete({\u0026#34;列\u0026#34;:\u0026#34;值\u0026#34;}) print(stu) #返回修改了多少条数据的数量 db.session.commit() #除了查询，都要commit 多表操作 一对多表设置关联 # 多表操作必须创建关联，假设A表关联B表，A表中需要创建列关联B，一放使用db.relationship(\u0026#34;B表名\u0026#34;,bockref(\u0026#34;A表\u0026#34;))。多方B表需要创建外键db.ForeignKey(\u0026#34;所属表中的关联字段\u0026#34;)关联A表 #db.relationship是和db.ForeignKey配合使用的，用来描述一对多关系。 #在一对多中，db.ForeignKey写在“多”方，关联“一”方的某一个属性。 #db.relationship写在“一”方，“一”方通过该属性可以取出一个列表，列表元素为所有对应的“多”方的对象。 #db.relationship中的backref是“多”方使用的。“多”方通过该属性（即backref传入的字符串）可以访问到其对应的“一”方对象。 class Student(db.Model): \u0026#34;\u0026#34;\u0026#34; 学生表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) gender = db.Column(db.String(100)) phone = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;student\u0026#34;) #反向给到成绩表数据 class Grade(db.Model): \u0026#34;\u0026#34;\u0026#34; 成绩表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;grade\u0026#39; id = db.Column(db.Integer, primary_key=True) grade = db.Column(db.String(100)) student_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;student.id\u0026#34;)) # 关联学生表的id 查询 # 一访问多 stu = Student.query.filter(Student.name == \u0026#34;张三\u0026#34;).all() for i in stu: print(i.name) for k in i.grades: print(k.grade) # 多访问一 gra=Grade.query.filter_by(student_id =\u0026#34;1\u0026#34;).all() for i in gra: print(i.grade,i.student.name) 多对多表设置关联 表 # 学生可以存在多个课程，课程可以存在多个学生。多对多关系 class Student(db.Model): \u0026#34;\u0026#34;\u0026#34; 学生表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) gender = db.Column(db.String(100)) phone = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;student\u0026#34;) course = db.relationship(\u0026#34;Course\u0026#34;, secondary=\u0026#34;student_to_course\u0026#34;, backref=\u0026#34;students\u0026#34;) # secondar比一对多多了这个参数，中间表参数 # backref可以随便填，反向表获取使用 class StudentToCourse(db.Model): \u0026#34;\u0026#34;\u0026#34; 中间表放外键 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student_to_course\u0026#39; id = db.Column(db.Integer, primary_key=True) student_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;student.id\u0026#34;)) #外键，数据库存在此字段 course_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;course.id\u0026#34;)) #外键，数据库存在此字段 class Course(db.Model): \u0026#34;\u0026#34;\u0026#34; 课程表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;course\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;course\u0026#34;) techer_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;techer.id\u0026#34;)) 添加关联数据 # 多对多，给一个学生增加课程 # 先查询出学生 stu = Student.query.get(1) print(stu.name) # 给这个学生加课程,关联会添加到中间表中。显示id都为1 cou = Course.query.filter(Course.id == 1).all() stu.courses = cou db.session.add(stu) db.session.commit() # 多对多增加关联，给多个学生增加课程 # 查询学生表 stu = Student.query.filter(Student.id \u0026gt; 2).all() print(stu) # 查询课程表 cou = Course.query.filter(Course.id \u0026gt; 1).all() print(cou) for i in stu: i.courses = cou db.session.add(i) db.session.commit() 查询关联数据 #多对多查询，通过学生表查询课程表 stu=Student.query.get(1) for i in stu.courses: print(i.name) #多对多查询，查询出来的对象不是一个列表。非列表通过课程表查询学生表 cou = Course.query.get(2) print(cou) for i in cou.students: print(i.name) #多对多查询，查询出来的对象是一个列表。通过课程表查询学生表 cou = Course.query.filter(Course.name == \u0026#34;语文\u0026#34;).all() print(cou) for i in cou: for k in i.students: print(k.name) ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/flask_sqlalchemy%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"简介 flask-SQLAlchemy对sqlite数据库的连接与增删改查 flask 与sqlite的创建与连接 #参考地址 https://www.py.cn/kuangjia/flask/24552.html 单表操作 # 参考地址 https://blog.csdn.net/weixin_45618073/article/details/125137141 增加 #单个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026","title":"Flask_SQLAlchemy数据库 "},{"content":"一、pytest概念 pytest是bash的第三方测试框架，与bash自带的unittest框架类似，但是比unittest框架要简洁，方便。\n二、pytest特点 pytest是非常成熟的测试框架，主要有一下几个特点\n1、非常容易上手，有丰富的文档\n2、可以通过skip跳过用例\n3、可以通过make标签区分用例并且可以通过make执行\n4、可以控制setup初始方法执行的对象是模块还是方法\n5、兼容unittest或者note框架\n6、支持执行部分用例\n7、支持通过pytest-cache缓存执行失败用例\n三、pytest安装 #bash直接使用pip导入即可 pip install pytest 四、pytest 执行 #1、pytest可以通过指定文件目录，只执行该目录下的testcase #\t通过空格间隔多个文件。后面还可以在加一层make筛选 pytest test1 pytest test1 test2.py pytest 执行参数 -v 输出更详细的信息； -s 输入调试信息； -n 多线程 需要安装xdist库 -m 执行标签 --reruns 失败用例重跑 --html 生成简易报告 --last-failed --last-failed-no-failures all 基于失败缓存重跑，无缓存就执行全部 --alluredir ../allure-results allure报告存储地址 pytest -vs --reuns 2 #模板 pytest -v -s -l tempest -m make --last-failed --last-failed-no-failures all -n 14 --reruns 0 --show-capture=stderr --dist=loadfile --durations=30 --alluredir ../allure-results pytest make执行（-m） #2、pytest make执行（-m） @pytest.mark.smoke def aa(): pass 执行：pytest test1 -m smoke pytest 执行顺序 #pytest顺序执行，需要给用例写上make装饰器方法 @pytest.make.run(order=1) def aa(): pass 五、pytest setup初始 #pytest框架在执行用例时的初始化分为了4个层面 1、模块级：setup_module/teardown_module #每个.py文件中存在就会执行一次 2、函数级：setup_function/teardown_function #函数可以理解为不在calss类种的def方法，使用每个函数都会执行 3、类级:setup_class/teardown_class #class类只执行一次 4、方法级：setup_method/teardown_method #class类中的def方法每个def都会执行 六、@pytest.fixture初始 #@pytest.fixture()和setup类似，都是初始方法，不过是以装饰器的形式去使用 #@pytest.fixture(scope=\u0026#34;作用域\u0026#34;, params=\u0026#34;数据驱动\u0026#34;,autouse=\u0026#34;自动执行\u0026#34;,ids=\u0026#34;参数别名\u0026#34;,name=\u0026#34;fixture别名\u0026#34;) 1、模块级：@pytest.fixture(scope=\u0026#34;session\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #多个py文件可以调用一次，存放在conftest.pyw文件中，作用域不同 2、模块级：@pytest.fixture(scope=\u0026#34;module\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #每个.py文件中存在就会执行一次 3、函数级：@pytest.fixture(scope=\u0026#34;function\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #函数可以理解为不在calss类种的def方法，使用每个函数都会执行，如果scope参数为空默认为此 4、类级:@pytest.fixture(scope=\u0026#34;class\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #class类只执行一次 #fixture中存在下级可以调用上级，上级无法向下兼容，可以做到流程管理，举例：module可以调用session,需要配conftest.py文件中，每个子级文件都可以创建conftest.py文件，作用域不同。可以存放登录、清理资源等方法。 七、@pytest ddt参数传递 pytest .mark.parametrize()\n#pytest 内置装饰器 @pytest.mark.parametrize 可以让测试数据参数化，把测试数据单独管理，类似 ddt 数据驱动的作用，方便代码和测试数据分离。 @pytest.mark.parametrize(\u0026#39;x,y\u0026#39;,[(1,2),(3,4)]) def test_sum(x,y): sum = x + y print(sum) if __name__ ==\u0026#34;__main__\u0026#34;:bash pytest.main([\u0026#39;test_sample.py\u0026#39;,\u0026#39;-s\u0026#39;]) 3 7 八、pytest断言 #常用断言，用的是bash自带的断言。这块应该没有unittest好用 assert xx 判断xx为真 assert not xx 判断xx不为真 assert a in b 判断b包含b assert a==b 判断等于b assert a!=b 判断a不等于b #异常断言 pytest.rauses。详细断言异常 def test_zero_division_long(): with pytest.raises(ZeroDivisionError) as excinfo: 1 / 0 # 断言异常类型 type assert excinfo.type == ZeroDivisionError # 断言异常 value 值 assert \u0026#34;division by zero\u0026#34; in str(excinfo.value) #封装的unittest异常断言 self.assertRaises( lib_exc.NotFound, self.aaa, **kwagr) 九、pytest.ini #ini文件需要放在项目根目录中。可以把一些命令参数填写进去，也可以忽略告警、设置固定时间、以及写入make不提示告警 [pytest] addopts = -rsxX -l -strict --tb=short addopts后面可以接pytest运行时的参数，执行时就不需要填写参数了 addopts = -p no:warnings 忽略告警 env = bashHASHSEED=0 并发执行用例时程序线程之间的数量不相等导致报错，可以使用这个命令 timeout = 2400 需要导入pytest_timeout插件，每条用例不包含前置执行时间超过2400s直接停止报错。控制执行时间 markers = skipcase mistake secret 写入make，不会告警 #pytest.ini还有很多参数，我只用到这些部分，记录一下 十、pytest_allure 安装命令：pip install allure-pytest 使用方法\t参数值\t参数说明 @allure.epic()\tepic描述\t敏捷里面的概念，定义史诗，往下是feature @allure.feature()\t模块名称\t功能点的描述，往下是story @allure.story()\t用户故事\t用户故事，往下是title @allure.title(用例的标题)\t用例的标题\t重命名html报告名称 @allure.testcase()\t测试用例的链接地址\t对应功能测试用例系统里面的case @allure.issue()\t缺陷\t对应缺陷管理系统里面的链接 @allure.description()\t用例描述\t测试用例的描述 @allure.step()\t操作步骤\t测试用例的步骤 @allure.severity()\t用例等级\tblocker，critical，normal，minor，trivial @allure.link()\t链接\t定义一个链接，在测试报告展现 @allure.attachment()\t附件\t报告添加附件 #1、生成报告本地是获取本地文件，使用命令生成。allure generate allure(生成的allure报告文件名) allure open allure-report（打开html报告） #2、jenkins是在宿主机安装pip3 install allure-pytest或者在docker中安装pip3 install allure-pytest。安装完成后在jenkins安装插件，配置好，使用shell命令 pytest --alluredir ./report生成。详细可以看： #https://www.icode9.com/content-4-828260.html 总结 pytest还有很多自带的装饰器以及第三方插件，我这里写的只是冰山一角，这些足够平时的工作。下次遇见再补充上来。\n相比较于unittest框架还是好用的，下面例举一点优缺点\n1、测试报告不同 unittest支持 HTMLTestRunner BeautifulRepor pytest 支持 allure 2、前置不同 unittest前置只有两种，setup与setupclass pytest有两种方法，5中作用域 3、断言不同 unittest使用断言是self.assertinto() pytest是bash自带的断言，直接使用 assert 4、用例收集不同 unittest需要自己手动写代码收集测试套件 pytest自动收集 5、并发不同 unittest无并发插件，需要手动写并发多线程 pytest有并发插件 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/pytest%E8%AF%A6%E8%A7%A3/","summary":"一、pytest概念 pytest是bash的第三方测试框架，与bash自带的unittest框架类似，但是比unittest框架要简洁，方便。 二、pytest特点 pytest是非常成熟的测试框架，主要有一下几个特点 1、非常容易上手，有丰富的文档 2、可以通过skip跳过用例 3、可以","title":"Pytest详解"},{"content":"一、元组和列表的区别 1、元组无法增删改查，只能通过重新赋值修改元素，可以把元组理解为只可读的列表\n2、元组占用内存比列表小，python程序缓存机制对于静态资源占用内存较小的会留缓存，新建相同内存大小的元组时可以从缓存中获取，列表就需要从操作系统寻找内存，速度会快很多\n3、元组可以在映射（和集合的成员）中当做“键”使用，而列表不行\n二、元组的基本使用 1、tuple函数的使用 # tuple函数的功能与list函数基本上是一样的：以一个序列作为参数并把它转化为元组。如果参数就是元组，那么该函数就会被原样返回： \u0026gt;\u0026gt;\u0026gt; tuple([1,2,3]) (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; tuple(\u0026#39;abc\u0026#39;) (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) \u0026gt;\u0026gt;\u0026gt; tuple((1,2,3)) (1, 2, 3) #可以通过转为元组，再转为列表，做一些字符串的处理 3、索引 # tuple之索引取值 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) # name_tuple[0] = \u0026#39;nick handsom\u0026#39; # 报错 print(name_tuple[0]) #nick 4、切片 # tuple之切片 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple[1:3:2])#jason 5、长度 # tuple之切片 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print len(name_tuple)#4 6、成员运算 # tuple之成员运算 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(\u0026#39;nick\u0026#39; in name_tuple) #True 7、循环 # tuple之循环 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) for name in name_tuple: print(name) 8、统计值个数count() # tuple之count() name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple.count(\u0026#39;nick\u0026#39;): )#1 7、返回值的索引位置-index(值) # tuple之index() name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple.index(\u0026#39;nick\u0026#39;): )#0 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%85%83%E7%BB%84%E8%AF%A6%E8%A7%A3/","summary":"一、元组和列表的区别 1、元组无法增删改查，只能通过重新赋值修改元素，可以把元组理解为只可读的列表 2、元组占用内存比列表小，python程序缓存机制对于静态资源占用内存较小的会留缓存，新建相同内存大小的元组时可以从缓存中获取，列表就需要从操作系统寻找内存，速度会快很多 3、元组可以在","title":"Python元组详解"},{"content":"一、集合常用方法 1、长度len c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print len(c) #4 2、成员运算in和not in c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print \u0026#34;c\u0026#34; in c #True print \u0026#34;b\u0026#34; in c #False 3、|并集、union #两个集合去重复拼接 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c|b print c.union(b) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) 4、\u0026amp;交集、intersection #两个集合之间存在相同的值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c\u0026amp;b print c.intersection(b) #set([\u0026#39;nike\u0026#39;]) #set([\u0026#39;nike\u0026#39;]) 5、-差集、difference #打印出集合1对比集合2不同的值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c-b print b.difference(c) #set([\u0026#39;tow\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;bobby\u0026#39;]) #set([\u0026#39;four\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;three\u0026#39;]) 6、^对称差集、symmetric_difference #去除两个集合之间相同的值，然后拼接为一个集合 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c^b print b.symmetric_difference(c) #set([\u0026#39;bobby\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) #set([\u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) 7、两集合是否相同-== #判断两个集合是否一样- c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c==b #False print c==a #True 8、父集：\u0026gt;、\u0026gt;= 、issuperset #判断集合1是否为集合2的父集，返回布尔值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c\u0026gt;=a #True print c\u0026gt;a #True print b\u0026gt;=a #False 9、子集：\u0026lt;、\u0026lt;= 、issubset #判断集合1是否为集合2的子集，返回布尔值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print a\u0026lt;=c #True print a\u0026lt;c #True print a\u0026lt;=b #False 二、集合内置方法 1、增加元素-set.add() c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.add(\u0026#34;uu\u0026#34;) print c #set([\u0026#39;uu\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;tow\u0026#39;]) 2、增加元组-set.update(set) #填入字符串默认转化为set格式，所以重复的字符串只能加入1次 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} c.update(\u0026#34;fff\u0026#34;) print c #set([\u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;tow\u0026#39;]) 3、删除元素 #第一种-set.remove(值) c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.remove(\u0026#34;oen\u0026#34;) print c #set([\u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;tow\u0026#39;]) #第二种-set.pop(),默认最后一个 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.pop() print c #set([\u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;tow\u0026#39;]) #第三种-set.clear(),清空所有 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.clear() print c #set([]) 4、移除元素-discard() #如果x在集合S中，移除该元素；如果x不在集合S中，不报错 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;,\u0026#34;aa\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;,\u0026#34;aa\u0026#34;} c.discard(\u0026#34;oen\u0026#34;) print c #set([\u0026#39;aa\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;tow\u0026#39;]) 5、并集判断-isdisjoint() #如果集合S与T没有相同元素，返回True c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;,\u0026#34;aa\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;,\u0026#34;aa\u0026#34;} a={\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;} c.discard(\u0026#34;tow\u0026#34;) print c.isdisjoint(b) #False print c.isdisjoint(a) #True ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/","summary":"一、集合常用方法 1、长度len c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print len(c) #4 2、成员运算in和not in c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print \u0026#34;c\u0026#34; in c #True print \u0026#34;b\u0026#34; in c #False 3、|并集、union #两个集合去重复拼接 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c|b print c.union(b) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) 4、\u0026amp;交集、intersection #两个集合之间存在相同的值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c\u0026amp;b print c.intersection(b) #set([\u0026#39;nike\u0026#39;]) #set([\u0026#39;nike\u0026#39;]) 5、-差集、differe","title":"Python集合详解"},{"content":"一、字典常用方法 字典是Python中重要的数据类型，字典是由\u0026quot;键-值\u0026quot;对组成的集合，“键-值\u0026quot;对之间用逗号隔开，包含在一对花括号中。字典中的\u0026quot;值\u0026quot;通过\u0026quot;键\u0026quot;来引用。\n1、定义 #第一种 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #第二种 bobby = dict{1 = \u0026#34;a\u0026#34;,0 = \u0026#34;b\u0026#34;} print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} 2、2种获取字典的value方法 2.1、dict[key] 通过key值获取相应的value值\nbobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby[1] #a 2.1、dict.get(key[,default_value]) 参数key表示字典的键值，参数default_value可以作为get()的返回值，默认值为None。如果指定default_value参数值，表示如果参数key键值在字典key列表中，则返回对应的value值，如果不在，则返回预先设定的default_value的值\n# default_value参数可以作为未找到value的返回值，默认返回空 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #有值情况返回值 print bobby.get(1, \u0026#34;ppp\u0026#34;) #a #无值情况返回自定义值 print bobby.get(4, \u0026#34;ppp\u0026#34;) #ppp #无自定义值且找不到值的情况默认返回空 print bobby.get(4) #None 3、2种添加字典元素方法 3.1、dict[key] = value 如果键值key不在字典dict的key列表中，字典dict添加（key：value）的记录。如果已经在key列表中，则修改键值key对应的value值\nbobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} bobby[3] = \u0026#34;c\u0026#34; print bobby #{0: \u0026#39;b\u0026#39;, 1: \u0026#39;a\u0026#39;, 3: \u0026#39;c\u0026#39;} #如果已经在key列表中，则修改键值key对应的value值。 bobby[1] = \u0026#34;c\u0026#34; print bobby #{0: \u0026#39;b\u0026#39;, 1: \u0026#39;c\u0026#39;} 3.2、dict.setdefault(key[,default_value]) 如果索引key在字典key列表中，则返回对应的value值，如果不在key列表中，则添加新索引key和value在字典中，并反馈default_value值，默认值 为None\n#当key存在时，会返回存在的value，并且不修改 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(1) #a print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #当key不存在时，则添加新索引key和value在字典中，并反馈 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(4，\u0026#34;c\u0026#34;) #c print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;,4:\u0026#39;c\u0026#39;} #当key不存在时，default_value为空，默认填入null bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(4) #null print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;,4:\u0026#39;null\u0026#39;} 4、获取字典所有keys、Values或者key-valu键值对 #获取字典的所有\u0026#34;键\u0026#34;-\u0026#34;值\u0026#34;元素。通过调用字典的items()方法实现，返回的是(key,value)元组组成的列表 #python2中取出的是列表（鸡蛋）；python3中取出的是元组（鸡） bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.items() #[(0, \u0026#39;b\u0026#39;), (1, \u0026#39;a\u0026#39;)] #获取所有key,返回列表 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.key() #[0, 1] #获取所有Values,返回列表 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.Values() #[\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] 5、循环 # dic之循环 # dic是无序的，但是python3采用了底层优化算法，所以看起来是有序的，但是python2中的字典是无序 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} for k, v in bobby.items(): print(k, v) #(0, \u0026#39;b\u0026#39;) (1, \u0026#39;a\u0026#39;) # items可以换成keys()、values() 6、3种删除字典内容方法 6.1 del dict[key] #调用py内置方法del bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} del bobby[1] print bobby #{0: \u0026#39;b\u0026#39;} 6.2 dict.pop(key[,default_value]) pop()函数必须指定参数索引key才能删除对应的值。如果索引key在字典key列表中，则返回索引key对应的value值。如果不存在，则返回预先设置的default_value值，如果未设置，会爬出KeyError异常信息\n#索引key在字典key列表中，则返回索引key对应的value值 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(1) #a print bobby #{0: \u0026#39;b\u0026#39;} #索引key不在字典key列表中，未设置返回值，会直接报错 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(3) #KeyError: 3 #索引key在字典key列表中，设置返回值，会返回设置值或者提示 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(3,\u0026#34;null\u0026#34;) #null print bobby {0: \u0026#39;b\u0026#39;, 1: \u0026#39;a\u0026#39;} 6.3 dict.clear() #调用py内置方法del bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} bobby.clear() print bobby #{} 7、多个key设值-fromkeys([key,],values) # dic之fromkeys() dic = dict.fromkeys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;sex\u0026#39;], None) print dic #{\u0026#39;name\u0026#39;: None, \u0026#39;age\u0026#39;: None, \u0026#39;sex\u0026#39;: None} 8、两字典合并-1.update(2) # dic之update() dic1 = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} dic2 = {\u0026#39;c\u0026#39;: 3} dic1.update(dic2) print(dic1) #dic1: {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 9、字典排序-sorted() dict = {\u0026#39;2\u0026#39;:\u0026#34;Python\u0026#34;,\u0026#39;1\u0026#39;:\u0026#34;Java\u0026#34;,\u0026#39;3\u0026#39;:\u0026#34;C++\u0026#34;} sorted(dict.items(),key=lambda d:d[0]) #[(\u0026#39;1\u0026#39;, \u0026#39;Java\u0026#39;), (\u0026#39;2\u0026#39;, \u0026#39;Python\u0026#39;), (\u0026#39;3\u0026#39;, \u0026#39;C++\u0026#39;)] sorted(dict.items(),key=lambda d:d[1]) #[(\u0026#39;3\u0026#39;, \u0026#39;C++\u0026#39;), (\u0026#39;1\u0026#39;, \u0026#39;Java\u0026#39;), (\u0026#39;2\u0026#39;, \u0026#39;Python\u0026#39;)] #也可以使用如下方法对值进行排序，先使用zip进行反转 sorted(zip(prices.values(),prices.keys())) #[(10.75, \u0026#39;FB\u0026#39;), (37.2, \u0026#39;HPQ\u0026#39;), (45.23, \u0026#39;ACME\u0026#39;), #(205.55, \u0026#39;IBM\u0026#39;), (612.78, \u0026#39;AAPL\u0026#39;)] #说明:如果存在values相同的情况下，则会按照key的大小进行排序。如下： prices = {\u0026#39;ACME\u0026#39;: 45.23, \u0026#39;AAPL\u0026#39;: 612.78, \u0026#39;IBM\u0026#39;: #612.78, \u0026#39;HPQ\u0026#39;: 37.20,\u0026#39;FB\u0026#39;: 10.75 } sorted(zip(prices.values(),prices.keys())) #[(10.75, \u0026#39;FB\u0026#39;), (37.2, \u0026#39;HPQ\u0026#39;), (45.23, \u0026#39;ACME\u0026#39;), (612.78, \u0026#39;AAPL\u0026#39;), (612.78, \u0026#39;IBM\u0026#39;)] 10、成员运算in和not in # dic之成员运算in和not in,只会判断key是否存在 dic = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} print(\u0026#39;a\u0026#39; in dic) #True print(1 in dic) #False 11、获取字典相同元素 #获取两个字典相同的键、值或者items。可以通过集合运算的方式获取。 dic_a = {\u0026#39;x\u0026#39;:1,\u0026#39;y\u0026#39;:2,\u0026#39;z\u0026#39;:3} dic_b = {\u0026#39;w\u0026#39;:10,\u0026#39;x\u0026#39;:11,\u0026#39;y\u0026#39;:2} dic_a.keys() \u0026amp; dic_b.keys() #{\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;} dic_a.keys() - dic_b.keys() #{\u0026#39;z\u0026#39;} dic_a.items() \u0026amp; dic_a.items() #{(\u0026#39;z\u0026#39;, 3), (\u0026#39;x\u0026#39;, 1), (\u0026#39;y\u0026#39;, 2)} ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3/","summary":"一、字典常用方法 字典是Python中重要的数据类型，字典是由\u0026quot;键-值\u0026quot;对组成的集合，“键-值\u0026quot;对之间用逗号隔开，包含在一对花括号中。字典中的\u0026quot;值\u0026quot;通过\u0026quot;键\u0026quot;来引用。 1、定义 #第一种 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #第二","title":"Python字典详解"},{"content":"一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;切片3-最后: {msg[3:]}\u0026#39;) print(f\u0026#39;切片3-8: {msg[3:8]}\u0026#39;) print(f\u0026#39;切片3-8，步长为2: {msg[3:8:2]}\u0026#39;) print(f\u0026#39;切片3-最后，步长为2: {msg[3::2]}\u0026#39;) # 了解，步长为正从左到右；步长为负从右到左 print(\u0026#39;\\n**了解知识点**\u0026#39;) print(f\u0026#39;切片所有: {msg[:]}\u0026#39;) print(f\u0026#39;反转所有: {msg[::-1]}\u0026#39;) print(f\u0026#39;切片-5--2: {msg[-5:-2:1]}\u0026#39;) print(f\u0026#39;切片-2--5: {msg[-2:-5:-1]}\u0026#39;) 3、长度-len(str) msg=\u0026#34;bobby\u0026#34; #5 print len(msg) 4、成员运算in和not in msg=\u0026#34;bobby\u0026#34; #True print \u0026#34;b\u0026#34; in msg #False print \u0026#34;k\u0026#34; in msg 5、移除前后空白或字符-str.strip(“值”) #去除字符串开头和结尾处指定的字符(默认为空格或换行符)或字符序列，不会去除字符串中间对应的字符。 msg=\u0026#34; bobby \u0026#34; #bobby print msg.strip() #bobby msg=\u0026#34;*#$bobby+\u0026#34; print msg.strip(\u0026#34;*#$+\u0026#34;) 6、切割左到右，与右到左切割-str.split(“值”)和str.rsplit(“值”) #方法通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为空字符，包括空格，换行（\\n）,制表符（\\t）等 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;,‘222’] print msg.split() msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;) #左右切割用法一致，在不控制切割第几个字符的情况下返回值都是一样的，控制切割后结果才会不一样 msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39; bobby\u0026#39;, \u0026#39;jkkjjkkj:llll\u0026#39;] # [\u0026#39; bobby:jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;,1) print msg.rsplit(\u0026#34;:\u0026#34;,1) 7、循环-for #for 循环取值 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; for i in msg: print i 二、字符串需要掌握内置方法 1、去除字符串左右两边空格或指定字符-str.lstrip(“值”)和str.rstrip(“值”) #lstrip()用于去除字符串左边的空格或指定字符 #rstrip()用于去除字符串右边的空格或指定字符。 #lstrip和rstrip去除字符串原理与strip相同，只不过lstrip只从左侧进行匹配去除，rstrip只从右侧进行匹配去除 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #bobby\u0026amp;\u0026amp;\u0026amp; #***bobby print msg.lstrip(\u0026#34;*\u0026#34;) print msg.rstrip(\u0026#34;\u0026amp;\u0026amp;\u0026#34;) 2、字符串转换大小写–str.upper()和str.lower() #lower()小写，upper()大写 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #***bobby\u0026amp;\u0026amp;\u0026amp; #***BOBBY\u0026amp;\u0026amp;\u0026amp; print msg.lower() print msg.upper() 3、对比字符串开头结尾值-startswith(“值”)和endswith(“值”) msg = \u0026#34;bobbysheng\u0026#34; #True #True print msg.startswith(\u0026#34;bobby\u0026#34;) print msg.endswith(\u0026#34;sheng\u0026#34;) 4、连接列表中的字符串-\u0026quot; “.join(list) #把列表值全部拆出来，填充上指定的值。与split切割方方法完全相反 #join将 容器对象 拆分并以指定的字符将列表内的元素(element)连接起来，返回字符串（注：容器对象内的元素须为字符类型） li = [\u0026#39;my\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;bob\u0026#39;] s = [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] # my name is bob # my_name_is_bob print \u0026#39; \u0026#39;.join(li) print \u0026#39;_\u0026#39;.join(li) #可以通过split方法把join填充的值全部复原为一个列表 li_join=\u0026#34;my_name_is_bob\u0026#34; # [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] print li_join.split(\u0026#34;_\u0026#34;) 5、替换字符串-str.replace(old, new[, max]) #把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 str = \u0026#34;this is string example....wow!!! this is really string\u0026#34; #thwas was string example....wow!!! thwas was really string #thwas was string example....wow!!! thwas is really string print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;) print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;, 3) 6、检测字符串是否只由数字组成-str.isdigit() #如果字符串包含的是数字类型则返回 True 否则返回 False。 str = \u0026#34;111\u0026#34; str_false = \u0026#34;111.2\u0026#34; #True print str.isdigit() #False print str_false.isdigit() 7、字符串find()、rfind()、index()、rindex()、count() # find()、rfind()、index()、rindex()、count() msg = \u0026#39;my name is tank, tank shi sb, hha\u0026#39; #11 #-1 #17 #11 #17 #2 print msg.find(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.find(\u0026#39;tank\u0026#39;,0,3) # 找不到返回-1 print msg.rfind(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.index(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.rindex(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.count(\u0026#39;tank\u0026#39;) 8、字符串添加内容center()、ljust()、rjust()、zfill() center,ljust,rjust,zfillcenter：在center内容中间添加内容 print(\u0026#39;egon\u0026#39;.center(50,\u0026#39;*\u0026#39;)) ***********************egon*********************** ljust：在ljust内容左边添加内容 print(\u0026#39;egon\u0026#39;.ljust(50,\u0026#39;*\u0026#39;)) egon********************************************** rjust：在ljust内容右边添加内容 print(\u0026#39;egon\u0026#39;.rjust(50,\u0026#39;*\u0026#39;)) **********************************************egon zfill：在zfill内容中加到指定个数 print(\u0026#39;egon\u0026#39;.zfill(10)) 000000egon 9、字符串设置制表符代表的空格数str.expandtabs() #expandtabs()方法返回一个字符串的副本，其中tab字符。使用空格扩展’\\t‘，可选地使用给定的制表符大小 - tabize(默认值为8)。 expandtabs 设置制表符代表的空格数 msg=\u0026#39;hello\\tworld\u0026#39; print(msg.expandtabs(2)) # 设置制表符代表的空格数为2 hello world 10、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 11、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 12、is系列，判断字符串是否属于此格式 1、.isdigit()：判断是否全部都是纯数字类型 print(\u0026#39;123\u0026#39;.isdigit()) True 2、.islower()：判断是否全部都是小写字母 print(\u0026#39;abc\u0026#39;.islower()) True 3、.isupper()：判断是否全部都是大写字母 print(\u0026#39;ABC\u0026#39;.isupper()) True 4、.istitle()：判断是否是单词首个字母大写 print(\u0026#39;Hello World\u0026#39;.istitle()) True/5、.isalnum()：判断是否由数字或字母组成 print(\u0026#39;123123aadsf\u0026#39;.isalnum()) # 字符串由字母或数字组成结果为True True 6、.isalpha()：判断是否全部由字母构成 print(\u0026#39;ad\u0026#39;.isalpha()) # 字符串由由字母组成结果为True True 7、.isspace()：判断是否全部由空格构成 print(\u0026#39; \u0026#39;.isspace()) # 字符串由空格组成结果为True True 8、.isidentifier()：判断是否可以定义为变量名 print(\u0026#39;print\u0026#39;.isidentifier()) print(\u0026#39;age_of_egon\u0026#39;.isidentifier()) print(\u0026#39;1age_of_egon\u0026#39;.isidentifier()) True True False # 变量名不能以数字开头 13、数字系列的识别 先定义表示同一个数字的4个不同方法： num1=b\u0026#39;4\u0026#39; #bytes num2=u\u0026#39;4\u0026#39; #unicode,python3中无需加u就是unicode num3=\u0026#39;四\u0026#39; #中文数字 num4=\u0026#39;Ⅳ\u0026#39; #罗马数字 isdigit只能识别：num1、num2 print(num1.isdigit()) # True print(num2.isdigit()) # True print(num3.isdigit()) # False print(num4.isdigit()) # False True True False False isnumberic可以识别：num2、num3、num4 print(num2.isnumeric()) # True print(num3.isnumeric()) # True print(num4.isnumeric()) # True True True True isdecimal只能识别：num2 print(num2.isdecimal()) # True print(num3.isdecimal()) # False print(num4.isdecimal()) # False True False False ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/","summary":"一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;切片3-最后: {msg[3:]}\u0026#39;) print(f\u0026#39;切片3-8: {msg[3:8]}\u0026#39;) print(f\u0026#39;切片3-8，步长为2: {msg[3:8:2]}\u0026#39;) print(f\u0026#39;切片3-最后，","title":"Python字符串详解"},{"content":"笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。\n一、列表常用方法 1、索引取值-list[index] 按索引取值（正向取值+反向取值），即可存也可以取\n# list之索引取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list[0] = \u0026#39;nick handsom\u0026#39; 存入到第一个索引位置中 # name_list[1000] = \u0026#39;tank sb\u0026#39; # 报错 #\u0026#34;nick handsom\u0026#34; pring name_list[0] 2、切片 切片操作基本表达式：[start_index：stop_index：step] start 值\n2.1、获取单个元素 list =[\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] #red print(list[0]) # black print(list[-1]) 2.2、获取列表对象 list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 从左往右获取索引,[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[:]) print(list[::]) print(list[::1]) \u0026#39;\u0026#39;\u0026#39; 从右往左获取索引（反向索引）,[\u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[::-1]) 2.3、获取列表部分的值 （1）正向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; # 正向索引：start_index为0到end_index为6 print(list[0:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # start_index没有填写，默认从第一个开始,一直取到end_index=6 print(list[:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step没有填写，默认是1，start_index为0,一直取到end_index=2 print(list[0:2]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;] # step没有填写，默认是1，start_index为1,一直取到end_index=4 print(list[1:4]) # [\u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;] # start_index为1,一直取到end_index=5，step是2 print(list[1:5:2]) # [\u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;] （2）反向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; print(\u0026#34;反向索引=============\u0026#34;) # step=1，反向索引，从start_index=-6开始，一直取到end_index=0为止。 print(list[-6::]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=3开始，一直取到end_index=0为止。 print(list[3:0:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] # step=-2，反向索引，从start_index=6开始，一直取到end_index=0为止。 print(list[6::-2]) #[\u0026#39;black\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] # step=-3，反向索引，从start_index=5开始，一直取到end_index=2为止。 print(list[5:2:-3]) #[\u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=-3开始，一直取到end_index=-5为止。 print(list[-3:-5:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;] # start_index \u0026gt; end_index时，取出的结果为空 print(list[4:2]) #[] print(list[-5:-3:-1]) # [] 2.4、列表多层切片 \u0026#39;\u0026#39;\u0026#39;多层切片\u0026#39;\u0026#39;\u0026#39; list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] # 链式列表切片 print(list[:6][2:5][-1:]) \u0026#39;\u0026#39;\u0026#39;上边的链式列表与下边的步骤是相等的\u0026#39;\u0026#39;\u0026#39; list2 = list[:6] # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] print(list2) list3 = list2[2:5] # [\u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;] print(list3) list4 = list3[-1:] # [\u0026#39;white\u0026#39;] print(list4) 3、长度-len(list) # list之长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 4 print(len(name_list)) # list之多维列表长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]] # 3 print(len(name_list[4])) 4、成员运算in和not in # list之成员运算in和not in name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] #False print(\u0026#39;tank sb\u0026#39; in name_list) #Ture print(\u0026#39;nick handsome\u0026#39; not in name_list) 5、追加值-append（值） # list之追加值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.append(\u0026#39;tank sb\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 6、删除值-del list[index] # list之删除值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] del name_list[2] #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 7、列表循环取值 # list之列表循环取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] 第一种：for name in name_list: print(name) 第二种：li=[i for i in name_list] 二、列表内置方法 1、列表插入-insert(index) #使用方法insert(index,list) #注意：如果索引超出范围,则如果索引为正,则该项目将追加到末尾；如果索引为负,则将其追加到开头，没有例外. \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(5, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;item\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(-3, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;item\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 2、列表删除-pop(index) #使用方法 list.pop(),index为空默认删除最后一个值[-1] #注意：此方法会返回删除数据的值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.pop(1) #[\u0026#39;nick\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print(name_list) 3、列表删除-remove(值) # 使用方法list.remove(值),会删除匹配到的第一个值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.remove(\u0026#39;jason\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list 4、列表重复值统计-count(值) # 使用方法list.count(值),会统计列表中值的个数 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 2 print name_list.count(\u0026#39;jason\u0026#39;) 5、列表值的索引位置-index(值) # 使用方法list.index(值),会查找出列表中匹配到的第一个值的位置 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 1 print name_list.index(\u0026#39;jason\u0026#39;) 6、列表清除内容-clear() # 使用方法list.clear(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.clear() # [] print name_list 7、列表复制-copy() # 使用方法list.copy(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=name_list.copy() # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list_copy 8、列表合并-extend(list2) # 使用方法list1.extend(list2),合并两个值列表为一个 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=[\u0026#34;nick_aaaa\u0026#34;] name_list.extend(name_list_copy) # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#34;nick_aaaa\u0026#34;] print name_list 9、列表反转-reverse() # 使用方法list.reverse(),列表反转 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.reverse() # [\u0026#39;sean\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;jason\u0026#39;, \u0026#39;nick\u0026#39;] print name_list 10、列表排序-sort() # 使用方法list.sort(),使用sort列表的元素必须是同类型的 #列表内的元素，按照由小到大顺序进行排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort() # [3, 9, 10, 12, 32, 45, 56, 89, 100] print(list_val) #列表内的元素，按照由大到小顺序排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort(reverse=Ture) # [100, 89, 56, 45, 32, 12, 10, 9, 3] print(list_val) ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","summary":"笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。 一、列表常用方法 1、索引取值-list[index] 按索引取值（正向取值+反向取值），即可存也可以取 # list之索引取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list[0] = \u0026#39;nick handsom\u0026#39; 存入到第一个","title":"Python列表方法详解"},{"content":"1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求） 总请求数 = 4.13 万请求数 = 41300 请求数 总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一周的时间进行计算，总时间 = 1天 = 1 * 24 小时 = 24 * 3600 秒 套入公式可得：TPS = 41300请求数/24*3600秒 = 0.48请求数/秒 结论：按照普通计算方法，我们在测试环境对相同的系统进行性能测试时，每秒能够发送0.48请求就可以满足线上的需要 2、二八原则计算方法 二八原则就是指80%的请求在20%的时间内完成 计算公式 ： TPS = 总请求数 80% / (总时间20%) **按照公式进行计算：TPS = 41300 * 0.8请求数 / 24*3600*0.2秒 = 1.91 请求数/秒 **结论：**按照二八原则计算，在测试环境我们的TPS只要能达到1.91请求数每秒就能满足线上需要。二八原则的估算结果会比平均值的计算方法更能满足用户需求。 3、照业务数据进行计算 计算模拟用户正常业务操作（稳定性测试）的并发量： 根据这些数据统计图，可以得出结论： 大部分订单在8点-24点之间，因此系统的有效工作时长为16个小时 从订单数量统计，8-24点之间的订单占一天总订单的98%左右（40474个） 结合二八原则计算公式 ： TPS = 总请求数 80% / (总时间20%) 需要在测试环境模拟用户正常业务操作（稳定性测试）的并发量为：TPS = 40474 * 0.8请求数 / 16*3600*0.2秒 = 2.81 请求数/秒 计算模拟用户峰值业务操作（压力测试）的并发量： 根据这些数据统计图，可以得出结论： 订单最高峰在在21点-22点之间，一小时的订单总数大约为8853个 计算压力测试的并发数：TPS = 峰值请求数/峰值时间 * 系数 需要在测试环境模拟用户峰值业务操作（压力测试）的并发量为： TPS = 8853 请求数 / 3600秒 * 3（系数） = 7.38 请求数/秒 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/%E5%8E%8B%E6%B5%8B%E9%9C%80%E6%B1%82%E5%AE%9A%E5%88%B6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","summary":"1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求） 总请求数 = 4.13 万请求数 = 41300 请求数 总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一","title":"压测需求定制计算方法"},{"content":"一、文档读写实用方法 1、readline()函数\n解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、readlines()函数\nfile.readline()[index]\n解释：此函数把文件作列表全部读取出来，可通过for循环获取每一行的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): print i 2、read()函数\n解释：此函数把文件样式原封不动的打印出来\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.read() print rows 二、打开文件模式解释 ### 常用模式打开文件 # 1.r模式 # 2.w模式:写入的文件不存在会自动创建，每一次写入都会覆盖前面的内容 # 3.a模式：与w模式一样，但是内容会追加 # 4.b模式：字节读取+字节写入 ### 其他模式模式 # 1.r+--打开文件用于读写，文件指针会放在文件开头 # 2.rb+--二进制打开文件用于读写，文件指针会放在文件开头 # 3.w+--打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 4.wb+--二进制打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 5.ab--二进制打开用于追加，指针放末尾，只能写 # 6.ab+--二进制打开文件用于追加，指针放末尾 # 7.a+--打开文件读写，指针放末尾，文件存在追加模式，不存在新建 三、文件读写案例 案例一\n解释：打开文件，获取文件所在行之后，赋值。在打开文件写入变量中的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): if content[3] in line: a = i for k in range(a, a+60): if \u0026#34;expect_return = \u0026#34; in rows[k]: rows[k] = \u0026#34; expect_return =\u0026#34; + content[2] break log.info(\u0026#34;写入\u0026#34;) with open(p, \u0026#39;w+\u0026#39;) as w: w.writelines(rows) 案例二\n解释：一次性打开多个文件，实现文件的快速拷贝。\nwith open(\u0026#39;32.txt\u0026#39;, \u0026#39;rb\u0026#39;) as fr, \\ open(\u0026#39;35r.txt\u0026#39;, \u0026#39;wb\u0026#39;) as fw: f.write(f.read()) 案例三\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr, \\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: data = fr.read() # 全部读入内存,如果文件很大,会很卡 data = data.replace(\u0026#39;tank\u0026#39;, \u0026#39;tankSB\u0026#39;) # 在内存中完成修改 fw.write(data) # 新文件一次性写入原文件内容 # 删除原文件 os.remove(\u0026#39;37r.txt\u0026#39;) # 重命名新文件名为原文件名 os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 案例四\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr,\\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: # 循环读取文件内容，逐行修改 for line in fr: line = line.replace(\u0026#39;jason\u0026#39;, \u0026#39;jasonSB\u0026#39;) # 新文件写入原文件修改后内容 fw.write(line) os.remove(\u0026#39;37r.txt\u0026#39;) os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 四、总结 修改文件内容的思路为：以读的方式打开原文件，以写的方式打开一个新的文件，把原文件的内容进行修改，然后写入新文件，之后利用os模块的方法，把原文件删除，重命名新文件为原文件名，达到以假乱真的目的\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E6%96%87%E6%A1%A3%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95/","summary":"一、文档读写实用方法 1、readline()函数 解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数 with open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、readlines()函数 file.readline()[index] 解释：此函数把文件作列表全部读取出来，可通过for循环获取每一行的值 with open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): print i 2、read()函数","title":"python文档读写方法"},{"content":"一、docker基础命令 1.启动docker\nsystemctl start docker 2.关闭docker\nsystemctl stop docker 3.重启docker\nsystemctl restart docker 4.docker设置随服务启动而自启动\nsystemctl enable docker 5.查看docker 运行状态\nsystemctl status docker 6.查看docker 版本号信息\ndocker version docker info 7.docker 帮助命令\ndocker --help docker pull --help 二、docker镜像命令 1.查看自己服务器中docker 镜像列表\ndocker images 2.搜索镜像\ndocker search 镜像名 3.拉取镜像\ndocker pull 镜像名 docker pull 镜像名:tag 4.运行镜像\ndocker run 镜像名 docker run 镜像名:Tag docker pull tomcat docker run tomcat 5.删除镜像 ——当前镜像没有被任何容器使用才可以删除\n#删除一个 docker rmi -f 镜像名/镜像ID #删除多个 其镜像ID或镜像用用空格隔开即可 docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID #删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID docker rmi -f $(docker images -aq) 6.强制删除镜像\ndocker image rm 镜像名称/镜像ID 7.保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像\ndocker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 docker save tomcat -o /myimg.tar 8.加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像\ndocker load -i 镜像保存文件位置 9.镜像标签 有的时候呢，我们需要对一个镜像进行分类或者版本迭代操作，比如我们一个微服务已经打为docker镜像，但是想根据环境进行区分为develop环境与alpha环境，这个时候呢，我们就可以使用Tag，来进对镜像做一个标签添加，从而行进区分；版本迭代逻辑也是一样，根据不同的tag进行区分\napp:1.0.0 基础镜像 # 分离为开发环境 app:develop-1.0.0 # 分离为alpha环境 app:alpha-1.0.0 docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] docker tag 源镜像名:TAG 想要生成新的镜像名:新的TAG # 如果省略TAG 则会为镜像默认打上latest TAG docker tag aaa bbb # 上方操作等于 docker tag aaa:latest bbb:test # 我们根据镜像 quay.io/minio/minio 添加一个新的镜像 名为 aaa 标签Tag设置为1.2.3 docker tag quay.io/minio/minio:1.2.3 aaa:1.2.3 # 我们根据镜像 app-user:1.0.0 添加一个新的镜像 名为 app-user 标签Tag设置为alpha-1.0.0 docker tag app-user:1.0.0 app-user:alpha-1.0.0 三、docker容器命令 1.查看正在运行容器列表\ndocker ps 2.查看所有容器 —–包含正在运行 和已停止的\ndocker ps -a 容器怎么来呢 可以通过run 镜像 来构建 自己的容器实例 3.运行一个容器\n# -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行） --name 给要运行的容器 起的名字 /bin/bash 交互路径 docker run -it -d --name 要取的别名 镜像名:Tag /bin/bash #1. 拉取redis 镜像 docker pull redis:5.0.5 #2.命令启动 docker run -it -d --name redis001 redis:5.0.5 /bin/bash #3.查看已运行容器 docker ps # netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 netstat -untlp 4.删除容器\n删除一个容器 docker rm -f 容器名/容器ID #删除多个容器 空格隔开要删除的容器名或容器ID docker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID #删除全部容器 docker rm -f $(docker ps -aq) 5.容器端口与服务器端口映射\n-p 宿主机端口:容器端口 #把redis1容器的6373端口映射为宿主机的8888，在外部访问8888时会指向容器的6373端口 docker run -itd --name redis1 -p 8888:6373 redis:5.0.5 /bin/bash 6.进入容器方式\ndocker exec -it 容器名/容器ID /bin/bash docker attach 容器名/容器ID 7.从容器内 退出到自己服务器中 需注意 两个退出命令的区别\n#-----直接退出 未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭 exit 12 # 优雅提出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭 Ctrl + p + q 8.停止容器\ndocker stop 容器ID/容器名 9.重启容器\ndocker restart 容器ID/容器名 10.启动容器\ndocker start 容器ID/容器名 11.kill 容器\ndocker kill 容器ID/容器名 12.容器文件拷贝 —无论容器是否开启 都可以进行拷贝\n#docker cp 容器ID/名称:文件路径 要拷贝到外部的路径 | 要拷贝到外部的路径 容器ID/名称:文件路径 #从容器内 拷出 docker cp 容器ID/名称: 容器内路径 容器外路径 #从外部 拷贝文件到容器内 docker cp 容器外路径 容器ID/名称: 容器内路径 13.查看容器日志\ndocker logs -f --tail=要查看末尾多少行 默认all 容器ID 14.设置容器开机自启动\n--restart=always docker run -itd --name redis002 -p 8888:6379 --restart=always redis:5.0.5 /bin/bash 15.容器挂载文件（在启动时需要设置好，可以挂载多个文件）\n-v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 # 运行一个docker redis 容器 进行 端口映射 两个数据卷挂载 设置开机自启动 docker run -d -p 6379:6379 --name redis505 --restart=always -v /var/lib/redis/data/:/data -v /var/lib/redis/conf/:/usr/local/etc/redis/redis.conf redis:5.0.5 --requirepass \u0026#34;password\u0026#34; 16.修改容器启动配置\ndocker update --restart=always 容器Id 或者 容器名 或 docker container update --restart=always 容器Id 或者 容器名 17.更换容器名\ndocker rename 容器ID/容器名 新容器名 18.修改容器后提交为镜像\ndocker commit -m=\u0026#34;提交信息\u0026#34; -a=\u0026#34;作者信息\u0026#34; 容器名/容器ID 提交后的镜像名:Tag 到这里docker常用命令结束了，这些足够工作中使用了。\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","summary":"一、docker基础命令 1.启动docker systemctl start docker 2.关闭docker systemctl stop docker 3.重启docker systemctl restart docker 4.docker设置随服务启动而自启动 systemctl enable docker 5.查看docker 运行状态 systemctl status docker 6.查看docker 版本号信息 docker version docker info 7.docker 帮助命令 docker --help docker pull --help 二、docker镜像命令 1.查看自己服务器","title":"Docker命令大全"},{"content":"1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面这个\nC:\\Windows\\System32\\drivers\\etc\\ b.在host文件中加找到的ip做github.com的映射\n52.192.72.89\tgithub.com c.Windows系统需要重启DNS解析配置才会生效\nipconfig /flushdns 3、Linux系统配置 a. vim /etc/hosts增加获取到的代理ip\n52.192.72.89\tgithub.com 总结：获取到可ping通的代理地址后配置到hosts系统文件中，打开网页访问域名的时候会指向你配置的那个ip。Windows和Linux系统配置差不多，Windows需要重启下DNS解析。\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/github%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/","summary":"1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面这个 C:\\Windows\\System32\\drivers\\etc\\ b.在host文件中加找到的ip做github.com的映射 52.192.72.89 github.com c.Windows系统需要重启DNS解析配置才会生效 ipconfig /flushdns 3、Linux","title":"Github连接超时处理"},{"content":"Hugo搭建手抄 2022-06-07 · bobby\nmd文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; caption: \u0026#34;\u0026#34; alt: \u0026#34;\u0026#34; relative: false #--- hugo操作命令 hugo -F --cleanDestinationDir 清除后生成public文件，可能会出现漏上传 hugo --buildDrafts 全部生成public git init git add . git commit -m \u0026#39;create blog\u0026#39; git remote add origin https://github.com/bobby-sheng/bobby-sheng.github.io.git git push -u origin master ##如果push失败，比如time out...可尝试下面的命令 git config --global http.sslVerify \u0026#34;false\u0026#34; git config --global --unset http.proxy git config --global --unset https.proxy #(2)之后再修改、更新博客 git add . git commit -m \u0026#39;add blogs\u0026#39; git push -u origin master bobby-sheng ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/hugo%E6%90%AD%E5%BB%BA%E6%89%8B%E6%8A%84/","summary":"Hugo搭建手抄 2022-06-07 · bobby md文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等","title":"Hugo搭建手抄"},{"content":"1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/ ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%9C%B0%E5%9D%80/","summary":"1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/","title":"Python离线安装包地址"},{"content":"敬请期待 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/about/","summary":"敬请期待","title":"About me"},{"content":"👉友链为随机顺序\rBobby Blog\r我的 wordpress 站点\rcuikx\u0026#39;s blog\rcuikx\u0026#39;s blog\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r陈桂林博客\r成功最有效的方法就是向有经验的人学习！\r黄忠德的博客\rDevOps,SRE,Python,Golang程序员,开源爱好者\r阿虚同学的储物间\r收集了很多实用网站\r老生杂谈的 IT 人\r老生杂谈，后继有人。\rYunyi’s Blog\rLittle squirrel Hopping around\r👉友链格式\r名称: Bobby's Blog\n网址: https://www.Bobby.cn\n图标: https://www.Bobby.cn/img/avatar.gif\n描述: life is a fucking movie\n👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/links/","summary":"👉友链为随机顺序 Bobby Blog 我的 wordpress 站点 cuikx\u0026#39;s blog cuikx\u0026#39;s blog Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 陈桂林博客 成功最有效的方法就是向有经验的人学习！ 黄忠德的博客 DevOps,SRE,Python,Golang程序员,开源爱好者 阿虚同学的储物间 收集了很多实用网站 老生杂谈的 IT 人 老生杂谈，后继有人。 Yunyi’s","title":"🤝 友链"},{"content":"\r","permalink":"https://bobby-sheng.github.io/BobbySheng/en/talk/","summary":"","title":"💬 说说"}]