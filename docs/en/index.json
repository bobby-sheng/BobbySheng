[{"content":"简介 flask-SQLAlchemy对sqlite数据库的连接与增删改查 flask 与sqlite的创建与连接 #参考地址 https://www.py.cn/kuangjia/flask/24552.html 单表操作 # 参考地址 https://blog.csdn.net/weixin_45618073/article/details/125137141 增加 #单个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026#34;) db.session.add(s1) db.session.commit() #除了查询，都要commit #多个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026#34;) stu2=Student(name=\u0026#34;李四\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1445\u0026#34;) stu3=Student(name=\u0026#34;王五\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1465245\u0026#34;) stu4=Student(name=\u0026#34;老王\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;145245\u0026#34;) db.session.add_all([stu,stu2,stu3,stu4]) db.session.commit() #除了查询，都要commit 查询 #单个数据查询id为1的数据表，返回一个对象 stu=Student.query.get(1) print(Student.name) #查询表中所有数据，返回一个列表，值为数据对象 stu=Student.query.all() for i in stu: print(Student.name) #打印表所有此字段值 #(类名.属性名 条件操作符 条件) 过滤特定条件,返回的是query对象 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first() #后面可以接.all() 表示取全部，.first() 表示取第一个值 for i in stu: print(表.列) #打印列表中数据所有此字段值 #(关键字参数对) 单条件查询,条件必须关键字参数,而且and连接 Student.query.filter_by(id=\u0026#34;1\u0026#34;).first() #后面可以接.all() 表示取全部，.first() 表示取第一个值，还可以继续接条件.filter(列=值)，或者.delete for i in stu: print(Student.name) #打印列表中数据所有此字段值 修改 #第一种，直接拼接在查询后面 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first().update({\u0026#34;列\u0026#34;:\u0026#34;值\u0026#34;}) print(stu) #返回修改了多少条数据的数量 db.session.commit() #除了查询，都要commit #第二种 改单个 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).first() stu.列=新值 #直接赋予新值 db.session.add(s1) #修改值的需要增加add方法 db.session.commit() #除了查询，都要commit #第二种 循环改多个 Student.query.filter(Student.id==\u0026#34;1\u0026#34;).all() for i in stu: i.列=新值 #直接赋予新值 db.session.add(s1) db.session.commit() #除了查询，都要commit 删除 #第一种，直接拼接在查询后面 stu=表名.query.filter(列=值).delete({\u0026#34;列\u0026#34;:\u0026#34;值\u0026#34;}) print(stu) #返回修改了多少条数据的数量 db.session.commit() #除了查询，都要commit 多表操作 一对多表设置关联 # 多表操作必须创建关联，假设A表关联B表，A表中需要创建列关联B，一放使用db.relationship(\u0026#34;B表名\u0026#34;,bockref(\u0026#34;A表\u0026#34;))。多方B表需要创建外键db.ForeignKey(\u0026#34;所属表中的关联字段\u0026#34;)关联A表 #db.relationship是和db.ForeignKey配合使用的，用来描述一对多关系。 #在一对多中，db.ForeignKey写在“多”方，关联“一”方的某一个属性。 #db.relationship写在“一”方，“一”方通过该属性可以取出一个列表，列表元素为所有对应的“多”方的对象。 #db.relationship中的backref是“多”方使用的。“多”方通过该属性（即backref传入的字符串）可以访问到其对应的“一”方对象。 class Student(db.Model): \u0026#34;\u0026#34;\u0026#34; 学生表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) gender = db.Column(db.String(100)) phone = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;student\u0026#34;) #反向给到成绩表数据 class Grade(db.Model): \u0026#34;\u0026#34;\u0026#34; 成绩表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;grade\u0026#39; id = db.Column(db.Integer, primary_key=True) grade = db.Column(db.String(100)) student_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;student.id\u0026#34;)) # 关联学生表的id 查询 # 一访问多 stu = Student.query.filter(Student.name == \u0026#34;张三\u0026#34;).all() for i in stu: print(i.name) for k in i.grades: print(k.grade) # 多访问一 gra=Grade.query.filter_by(student_id =\u0026#34;1\u0026#34;).all() for i in gra: print(i.grade,i.student.name) 多对多表设置关联 表 # 学生可以存在多个课程，课程可以存在多个学生。多对多关系 class Student(db.Model): \u0026#34;\u0026#34;\u0026#34; 学生表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) gender = db.Column(db.String(100)) phone = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;student\u0026#34;) course = db.relationship(\u0026#34;Course\u0026#34;, secondary=\u0026#34;student_to_course\u0026#34;, backref=\u0026#34;students\u0026#34;) # secondar比一对多多了这个参数，中间表参数 # backref可以随便填，反向表获取使用 class StudentToCourse(db.Model): \u0026#34;\u0026#34;\u0026#34; 中间表放外键 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;student_to_course\u0026#39; id = db.Column(db.Integer, primary_key=True) student_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;student.id\u0026#34;)) #外键，数据库存在此字段 course_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;course.id\u0026#34;)) #外键，数据库存在此字段 class Course(db.Model): \u0026#34;\u0026#34;\u0026#34; 课程表 \u0026#34;\u0026#34;\u0026#34; __tablename__ = \u0026#39;course\u0026#39; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100)) grades = db.relationship(\u0026#34;Grade\u0026#34;, backref=\u0026#34;course\u0026#34;) techer_id = db.Column(db.String(100), db.ForeignKey(\u0026#34;techer.id\u0026#34;)) 添加关联数据 # 多对多，给一个学生增加课程 # 先查询出学生 stu = Student.query.get(1) print(stu.name) # 给这个学生加课程,关联会添加到中间表中。显示id都为1 cou = Course.query.filter(Course.id == 1).all() stu.courses = cou db.session.add(stu) db.session.commit() # 多对多增加关联，给多个学生增加课程 # 查询学生表 stu = Student.query.filter(Student.id \u0026gt; 2).all() print(stu) # 查询课程表 cou = Course.query.filter(Course.id \u0026gt; 1).all() print(cou) for i in stu: i.courses = cou db.session.add(i) db.session.commit() 查询关联数据 #多对多查询，通过学生表查询课程表 stu=Student.query.get(1) for i in stu.courses: print(i.name) #多对多查询，查询出来的对象不是一个列表。非列表通过课程表查询学生表 cou = Course.query.get(2) print(cou) for i in cou.students: print(i.name) #多对多查询，查询出来的对象是一个列表。通过课程表查询学生表 cou = Course.query.filter(Course.name == \u0026#34;语文\u0026#34;).all() print(cou) for i in cou: for k in i.students: print(k.name) ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/flask_sqlalchemy%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"简介 flask-SQLAlchemy对sqlite数据库的连接与增删改查 flask 与sqlite的创建与连接 #参考地址 https://www.py.cn/kuangjia/flask/24552.html 单表操作 # 参考地址 https://blog.csdn.net/weixin_45618073/article/details/125137141 增加 #单个数据增加 stu=Student(name=\u0026#34;张三\u0026#34;,gender=\u0026#34;男\u0026#34;,phone=\u0026#34;1452\u0026","title":"Flask_SQLAlchemy数据库 "},{"content":"一、docker基础命令 1.启动docker\nsystemctl start docker 2.关闭docker\nsystemctl stop docker 3.重启docker\nsystemctl restart docker 4.docker设置随服务启动而自启动\nsystemctl enable docker 5.查看docker 运行状态\nsystemctl status docker 6.查看docker 版本号信息\ndocker version docker info 7.docker 帮助命令\ndocker --help docker pull --help 二、docker镜像命令 1.查看自己服务器中docker 镜像列表\ndocker images 2.搜索镜像\ndocker search 镜像名 3.拉取镜像\ndocker pull 镜像名 docker pull 镜像名:tag 4.运行镜像\ndocker run 镜像名 docker run 镜像名:Tag docker pull tomcat docker run tomcat 5.删除镜像 ——当前镜像没有被任何容器使用才可以删除\n#删除一个 docker rmi -f 镜像名/镜像ID #删除多个 其镜像ID或镜像用用空格隔开即可 docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID #删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID docker rmi -f $(docker images -aq) 6.强制删除镜像\ndocker image rm 镜像名称/镜像ID 7.保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像\ndocker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 docker save tomcat -o /myimg.tar 8.加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像\ndocker load -i 镜像保存文件位置 9.镜像标签 有的时候呢，我们需要对一个镜像进行分类或者版本迭代操作，比如我们一个微服务已经打为docker镜像，但是想根据环境进行区分为develop环境与alpha环境，这个时候呢，我们就可以使用Tag，来进对镜像做一个标签添加，从而行进区分；版本迭代逻辑也是一样，根据不同的tag进行区分\napp:1.0.0 基础镜像 # 分离为开发环境 app:develop-1.0.0 # 分离为alpha环境 app:alpha-1.0.0 docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] docker tag 源镜像名:TAG 想要生成新的镜像名:新的TAG # 如果省略TAG 则会为镜像默认打上latest TAG docker tag aaa bbb # 上方操作等于 docker tag aaa:latest bbb:test # 我们根据镜像 quay.io/minio/minio 添加一个新的镜像 名为 aaa 标签Tag设置为1.2.3 docker tag quay.io/minio/minio:1.2.3 aaa:1.2.3 # 我们根据镜像 app-user:1.0.0 添加一个新的镜像 名为 app-user 标签Tag设置为alpha-1.0.0 docker tag app-user:1.0.0 app-user:alpha-1.0.0 三、docker容器命令 1.查看正在运行容器列表\ndocker ps 2.查看所有容器 —–包含正在运行 和已停止的\ndocker ps -a 容器怎么来呢 可以通过run 镜像 来构建 自己的容器实例 3.运行一个容器\n# -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行） --name 给要运行的容器 起的名字 /bin/bash 交互路径 docker run -it -d --name 要取的别名 镜像名:Tag /bin/bash #1. 拉取redis 镜像 docker pull redis:5.0.5 #2.命令启动 docker run -it -d --name redis001 redis:5.0.5 /bin/bash #3.查看已运行容器 docker ps # netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 netstat -untlp 4.删除容器\n删除一个容器 docker rm -f 容器名/容器ID #删除多个容器 空格隔开要删除的容器名或容器ID docker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID #删除全部容器 docker rm -f $(docker ps -aq) 5.容器端口与服务器端口映射\n-p 宿主机端口:容器端口 #把redis1容器的6373端口映射为宿主机的8888，在外部访问8888时会指向容器的6373端口 docker run -itd --name redis1 -p 8888:6373 redis:5.0.5 /bin/bash 6.进入容器方式\ndocker exec -it 容器名/容器ID /bin/bash docker attach 容器名/容器ID 7.从容器内 退出到自己服务器中 需注意 两个退出命令的区别\n#-----直接退出 未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭 exit 12 # 优雅提出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭 Ctrl + p + q 8.停止容器\ndocker stop 容器ID/容器名 9.重启容器\ndocker restart 容器ID/容器名 10.启动容器\ndocker start 容器ID/容器名 11.kill 容器\ndocker kill 容器ID/容器名 12.容器文件拷贝 —无论容器是否开启 都可以进行拷贝\n#docker cp 容器ID/名称:文件路径 要拷贝到外部的路径 | 要拷贝到外部的路径 容器ID/名称:文件路径 #从容器内 拷出 docker cp 容器ID/名称: 容器内路径 容器外路径 #从外部 拷贝文件到容器内 docker cp 容器外路径 容器ID/名称: 容器内路径 13.查看容器日志\ndocker logs -f --tail=要查看末尾多少行 默认all 容器ID 14.设置容器开机自启动\n--restart=always docker run -itd --name redis002 -p 8888:6379 --restart=always redis:5.0.5 /bin/bash 15.容器挂载文件（在启动时需要设置好，可以挂载多个文件）\n-v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 # 运行一个docker redis 容器 进行 端口映射 两个数据卷挂载 设置开机自启动 docker run -d -p 6379:6379 --name redis505 --restart=always -v /var/lib/redis/data/:/data -v /var/lib/redis/conf/:/usr/local/etc/redis/redis.conf redis:5.0.5 --requirepass \u0026#34;password\u0026#34; 16.修改容器启动配置\ndocker update --restart=always 容器Id 或者 容器名 或 docker container update --restart=always 容器Id 或者 容器名 17.更换容器名\ndocker rename 容器ID/容器名 新容器名 18.修改容器后提交为镜像\ndocker commit -m=\u0026#34;提交信息\u0026#34; -a=\u0026#34;作者信息\u0026#34; 容器名/容器ID 提交后的镜像名:Tag 到这里docker常用命令结束了，这些足够工作中使用了。\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","summary":"一、docker基础命令 1.启动docker systemctl start docker 2.关闭docker systemctl stop docker 3.重启docker systemctl restart docker 4.docker设置随服务启动而自启动 systemctl enable docker 5.查看docker 运行状态 systemctl status docker 6.查看docker 版本号信息 docker version docker info 7.docker 帮助命令 docker --help docker pull --help 二、docker镜像命令 1.查看自己服务器","title":"Docker命令大全"},{"content":"0 前言 感谢 piclist 作者的 不吝解答\n最近从 typora 迁移到了 obsidian, typora 可以很方便的自动调用 picgo 实现图片上传, obsidian 得益于丰富的插件市场, 可以通过 Image Auto Upload Plugin 插件调用 picgo, 但是必须手动启动 picgo 后才能正常使用\n在插件配置的注释中发现了 piclist, 经了解发现这个二开版本支持 docker 部署, 综合考虑了一下还是值得折腾一下的, 既能避免手动打开 picgo 的繁琐, 也可以在我所有的 pc 上卸载掉一个软件, 同时还能水一文\n注意本文以已有服务器/ip/域名且 web 服务使用 nginx 为前提, 如果不满足上述前提, 需要将 piclist 的 36677 端口映射到主机, 部署完 piclist 后直接通过 ip 加端口的形式调用即可\n1 部署 1.1 piclist 配置 docker-compose.yml 中添加如下配置\nversion: \u0026#39;3.1\u0026#39; services: piclist: image: \u0026#39;kuingsmile/piclist:v1.7.0\u0026#39; container_name: piclist restart: always networks: blog_net: ipv4_address: 172.19.0.5 volumes: - \u0026#39;$PWD/data/piclist:/root/.piclist\u0026#39; # 需要设置 piclist_key 环境变量 command: node /usr/local/bin/picgo-server -k ${piclist_key} networks: blog_net: driver: bridge ipam: config: - subnet: 172.19.0.0/16 添加环境变量并启动 piclist 容器, 此环境变量用于 client(obsidian) 和 piclist server 之间的鉴权\n# 将 123456 设置为自定义的密码 cat \u0026gt;\u0026gt; ${HOME}/.bash_profile \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; export piclist_key=\u0026#39;123456\u0026#39; EOF source ${HOME}/.bash_profile docker-compose up -d 修改 data/piclist/config.json 的配置, 以阿里云 OSS 为例添加图床配置, 内容自行修改, 官方没有配置文件的详细文档, 可以折中一下, 先 windows 安装 piclist, 测试无误后导出配置\n{ \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;aliyun\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;aliyun\u0026#34;, \u0026#34;aliyun\u0026#34;: { \u0026#34;accessKeyId\u0026#34;: \u0026#34;******\u0026#34;, \u0026#34;accessKeySecret\u0026#34;: \u0026#34;******\u0026#34;, \u0026#34;bucket\u0026#34;: \u0026#34;Bobby-image\u0026#34;, \u0026#34;area\u0026#34;: \u0026#34;oss-cn-beijing\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;blog/\u0026#34;, \u0026#34;customUrl\u0026#34;: \u0026#34;https://image.Bobby.cn\u0026#34;, \u0026#34;options\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} } 最后再重启一下 piclist\ndocker restart piclist 1.2 nginx 配置 nginx 中添加如下 location 配置\nlocation /piclist/ { proxy_pass http://172.19.0.5:36677/; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-Port $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header HTTP_X_FORWARDED_FOR $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $host; proxy_set_header X-NginX-Proxy true; proxy_set_header Accept-Encoding \u0026#34;br\u0026#34;; } 执行 docker restart nginx-proxy 重启 nginx\n最后修改 obsidian 的 Image auto upload Plugin 插件的配置\n打开远程服务器模式 将接口 url 设置为 https://\u0026lt;你的域名\u0026gt;/piclist/upload?key=\u0026lt;你的key\u0026gt;, 这里的 key 就是启动容器时配置的环境变量的值, 需注意如果 key 中有特殊字符需要 url 转义一下 最后测试一下图片上传即可, 如果有报错可以通过 docker logs -f piclist 查看日志\n2 常见问题 2.1 上传失败 obsdian 直接提示上传失败, 可能是 key 中有特殊字符没有转义或者没有打开远程服务器模式 日志中有如下 Unauthorized access 报错, 一般是 key 不匹配 2.2 忘记 piclist_key 如果已经启动了的容器可以通过如下命令查看\ndocker exec -it piclist ps -ef | grep -v grep | grep node 以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/docker-deploy-piclist/","summary":"0 前言 感谢 piclist 作者的 不吝解答 最近从 typora 迁移到了 obsidian, typora 可以很方便的自动调用 picgo 实现图片上传, obsidian 得益于丰富的插件市场, 可以通过 Image Auto Upload Plugin 插件调用 picgo, 但是必须手动启动 picgo 后才能正常使用 在插件配置的注释中发现了 piclist, 经了解发现这个二开版本支持 docker 部署, 综合考虑了一下还是值得折腾一下的, 既能避免手动打开 picgo 的繁","title":"docker 部署 piclist"},{"content":"\n🏡 关于本站 本博客主要记录一些学习生活，和一些个人觉得值得记录的问题及其解决办法。如果本博客能有哪些内容帮助到了你，那也是极好的。\n👦🏻 博主是谁 网络时代的素质教育漏网之鱼 | 晚睡协会常任理事 | 国家级抬杠运动员 | 中国驰名窝里横 | 国宝级老污龟 | 超水平怼人大师 | 一秒入戏准影帝\n精通CSS、JavaScript、PHP、C、C＋＋、C#、java、Ruby、Perl、Lisp、python等单词的拼写；\n熟悉windows、Linux、Mac、Android、IOS等系统的开关机；\n🏹 兴趣爱好 🏃‍♂️ 跑步 | 🎮️ 游戏 | 🎧 音乐 | 📺 动漫 | 🛌 摆烂\n📈 博客变更记录 2022年9月8日 本博客正式加入 十年之约\n今夕何夕，人生能有几个十年\n2022年7月16日 迁移之前发布在 csdn 的文章，将图片外链全部转为七牛图床\n2022年7月4日 hugo 站点试运行，域名：https://www.Bobby.cn\n2021年8月15日 将阿里云轻量服务器自带的 wordpress 应用改为 docker 应用，wordpress 站点改为 docker-compose 部署\n2021年7月13日 wordpress 博客站点开始运行，域名：https://Bobby.cn\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/about/","summary":"🏡 关于本站 本博客主要记录一些学习生活，和一些个人觉得值得记录的问题及其解决办法。如果本博客能有哪些内容帮助到了你，那也是极好的。 👦🏻 博主是谁 网络时代的素质教育漏网之鱼 | 晚睡协会常任理事 | 国家级抬杠运动员 | 中国驰名窝里横 | 国宝级老污龟 | 超水平怼人大师 | 一秒入戏准影帝 精通CSS、Ja","title":"🙋🏻‍♂️ 关于"},{"content":"👉友链为随机顺序\rBobby Blog\r我的 wordpress 站点\rcuikx\u0026#39;s blog\rcuikx\u0026#39;s blog\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r陈桂林博客\r成功最有效的方法就是向有经验的人学习！\r黄忠德的博客\rDevOps,SRE,Python,Golang程序员,开源爱好者\r阿虚同学的储物间\r收集了很多实用网站\r老生杂谈的 IT 人\r老生杂谈，后继有人。\rYunyi’s Blog\rLittle squirrel Hopping around\r👉友链格式\r名称: Bobby's Blog\n网址: https://www.Bobby.cn\n图标: https://www.Bobby.cn/img/avatar.gif\n描述: life is a fucking movie\n👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/links/","summary":"👉友链为随机顺序 Bobby Blog 我的 wordpress 站点 cuikx\u0026#39;s blog cuikx\u0026#39;s blog Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 陈桂林博客 成功最有效的方法就是向有经验的人学习！ 黄忠德的博客 DevOps,SRE,Python,Golang程序员,开源爱好者 阿虚同学的储物间 收集了很多实用网站 老生杂谈的 IT 人 老生杂谈，后继有人。 Yunyi’s","title":"🤝 友链"},{"content":"\r","permalink":"https://bobby-sheng.github.io/BobbySheng/en/talk/","summary":"","title":"💬 说说"},{"content":"0 前言 本文参考以下链接:\n从能用到好用-快速搭建高性能WordPress指南 前段时间着手开始搭建自己的 wordpress 博客，刚开始图方便直接买了阿里云的轻量应用服务器，它是一套预先搭建好的 lamp 架构，并已经做了一些初始化配置，直接访问 ip 就可以进行 wordpress 的安装和配置了。\n这套 wordpress 的一个非常好的优点就是可以在阿里云的控制台一键配置 https 证书，当然仅限在阿里云购买的 ssl 证书\n后续还是决定将 wordpress 整体迁移到 docker 中，全部服务都用 docker 跑。这样只要数据做好持久化，使用 docker 的灵活性会好很多，做全站备份和迁移也很方便。\n1 备份\u0026amp;迁移 wordpress 迁移起来还是比较方便的，需要备份的内容大概有这些：插件、主题、uploads、数据库\n备份插件：UpdraftPlus，这是一款个人使用过一款比较优秀的备份/迁移插件，免费版的功能基本满足大部分人需求，支持手动备份和定时备份、备份和恢复都支持部分备份，比如只备份数据库，只恢复数据库的某一张表。\n免费版的并不支持 wordpress 迁移，但我们可以通过导入导出备份文件的方式实现站点迁移，前提是做好测试。\n备份步骤：\n在备份插件中手动备份一次 下载备份文件 迁移步骤：\n准备好系统环境和 docker 环境（docker-compose） 启动 docker 容器 http 访问 wordpress 地址初始化安装 安装备份插件和 ssl 插件（really simple ssl） 上传备份文件并进行恢复操作（不恢复 wp-options 表） 为 nginx 反代服务器配置 ssl 证书，开启 https 访问 在 really simple ssl 中为 wordpress 启用 https 恢复 wp-options 表 1.1 手动备份\u0026amp;下载备份文件 备份完之后可以直接从 web 端下载，但是建议从 web 端下载一份，通过 ssh 或者 ftp 等方式再下载一份，避免备份文件出现问题\n备份的文件在 wordpress目录/wp-content/updraft 目录中\n通过 scp 下载到本地\n1.2 准备系统环境 安装好 docker 和 docker-compose 即可，docker 的安装和使用教程在本博客中 docker 分类有\n1.3 docker-compose 一键启动 wordpress 环境 这里我提供了一键部署的 docker-compose 文件和各服务进行了优化的配置文件，可以直接拿来用 下载链接\n注意：\n使用前建议修改数据库相关信息\n建议不要随意改动 ip\n所有的数据文件和配置文件默认都在当前的目录下\n如果前面不加 nginx 反代，记得把注释掉的端口映射改成自己想要的\n所有的配置文件都在 nginx 目录下，已经预先定义好，可以自行进行修改\n内置的 wordpress 目录权限用户和组是 33:tape\nversion: \u0026#39;3.1\u0026#39; services: proxy: image: superng6/nginx:debian-stable-1.18.0 container_name: nginx-proxy restart: always networks: wordpress_net: ipv4_address: 172.19.0.6 ports: - 80:80 - 443:443 volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - $PWD/conf/proxy/nginx.conf:/etc/nginx/nginx.conf - $PWD/conf/proxy/default.conf:/etc/nginx/conf.d/default.conf - $PWD/ssl:/etc/nginx/ssl - $PWD/logs/proxy:/var/log/nginx depends_on: - web web: image: superng6/nginx:debian-stable-1.18.0 container_name: wordpress-nginx restart: always networks: wordpress_net: ipv4_address: 172.19.0.5 volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - $PWD/conf/nginx/nginx.conf:/etc/nginx/nginx.conf - $PWD/conf/nginx/default.conf:/etc/nginx/conf.d/default.conf - $PWD/conf/fastcgi.conf:/etc/nginx/fastcgi.conf - /dev/shm/nginx-cache:/var/run/nginx-cache # - $PWD/nginx-cache:/var/run/nginx-cache - $PWD/wordpress:/var/www/html - $PWD/logs/nginx:/var/log/nginx depends_on: - wordpress wordpress: image: wordpress:5-fpm container_name: wordpress-php restart: always networks: wordpress_net: ipv4_address: 172.19.0.4 environment: WORDPRESS_DB_HOST: db WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - $PWD/wordpress:/var/www/html - /dev/shm/nginx-cache:/var/run/nginx-cache # - $PWD/nginx-cache:/var/run/nginx-cache - $PWD/conf/uploads.ini:/usr/local/etc/php/php.ini depends_on: - redis - db redis: image: redis:5 container_name: wordpress-redis restart: always networks: wordpress_net: ipv4_address: 172.19.0.3 volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - $PWD/redis-data:/data depends_on: - db db: image: mysql:5.7 container_name: wordpress-mysql restart: always networks: wordpress_net: ipv4_address: 172.19.0.2 environment: MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress MYSQL_RANDOM_ROOT_PASSWORD: \u0026#39;1\u0026#39; volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - $PWD/mysql-data:/var/lib/mysql - $PWD/conf/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf networks: wordpress_net: driver: bridge ipam: config: - subnet: 172.19.0.0/16 进入到 wordpress-blog 目录下使用 docker-compose up -d 启动 docker 容器\n1.4 配置 nginx 反向代理 配置 80 和 443 端口的反代\n把域名、证书路径以及后端服务器等信息换成自己的\n免费 ssl 证书的申请我在 阿里云wordpress配置免费ssl证书 中介绍过，直接下载 nginx 版的证书放到 wordpress-blog/ssl/目录下即可\n[root@Bobby ~]# vim wordpress-blog/conf/proxy/default.conf server { listen 80; listen [::]:80; server_name Bobby.cn; # return 301 https://$host$request_uri; location / { proxy_pass http://172.19.0.5:80; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-Port $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header HTTP_X_FORWARDED_FOR $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $host; proxy_set_header X-NginX-Proxy true; } } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name Bobby.cn; location / { proxy_pass http://172.19.0.5:80; proxy_redirect off; # 保证获取到真实IP proxy_set_header X-Real-IP $remote_addr; # 真实端口号 proxy_set_header X-Real-Port $remote_port; # X-Forwarded-For 是一个 HTTP 扩展头部。 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 在多级代理的情况下，记录每次代理之前的客户端真实ip proxy_set_header HTTP_X_FORWARDED_FOR $remote_addr; # 获取到真实协议 proxy_set_header X-Forwarded-Proto $scheme; # 真实主机名 proxy_set_header Host $host; # 设置变量 proxy_set_header X-NginX-Proxy true; # 开启 brotli proxy_set_header Accept-Encoding \u0026#34;gzip\u0026#34;; } # 日志 access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; # 证书 ssl_certificate /etc/nginx/ssl/Bobby.cn.pem; ssl_certificate_key /etc/nginx/ssl/Bobby.cn.key; # curl https://ssl-config.mozilla.org/ffdhe2048.txt \u0026gt; /path/to/dhparam # ssl_dhparam /etc/nginx/ssl/dhparam; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; # verify chain of trust of OCSP response using Root CA and Intermediate certs # ssl_trusted_certificate /etc/nginx/ssl/all.sleele.com/fullchain.cer; # replace with the IP address of your resolver resolver 223.5.5.5; resolver_timeout 5s; } [root@Bobby ~]# docker exec -i nginx-proxy nginx -s reload 1.5 安装 wordpress 现在已经可以通过 http 访问 nginx 反代的 80 端口访问 wordpress 了\n安装信息跟之前站点设置一样即可\n1.6 恢复备份 安装好之后启用插件，把备份文件上传到备份目录\n记得修改权限\n[root@Bobby ~]# chown -R 33:tape wordpress-blog/wordpress/wp-content/ 恢复备份\n注：如果站点之前开启了 https，在这步不要恢复 wp-options 表，不然会导致后台访问不了\n点击恢复即可\n1.7 配置 ssl 启用 really simple ssl 插件，因为之前在 nginx 反代配置了 ssl 证书，虽然我们没有通过 https 访问，但是这个插件已经检测到了证书，可以一键为 wordpress 配置 ssl\n这里我们已经可以通过 https 访问我们的 wordpress 了\n站点路径该插件也会自动修改，之前不恢复 wp-options 表的原因就在这，在我们没有配置好 ssl 之前，直接覆盖 wordpress 的各项设置会导致站点访问不了，重定向循环等各种各样的问题。\n1.8 恢复 wp-options 表 开启了 ssl 之后，通过备份插件再恢复一次，可以只恢复一张 wp-options 表，也可以再全量恢复下数据库，至此，站点迁移工作基本完成了。\n2 后续优化 2.1 开启 https 强制跳转 开启 https 强制跳转后，所有使用 http 访问我们站点的请求都会转到 https，提高站点安全性\n[root@Bobby ~]# vim /etc/nginx/nginx.conf server { listen 80; listen [::]:80; server_name Bobby.cn; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name Bobby.cn; location / { proxy_pass http://172.19.0.5:80; proxy_redirect off; # 保证获取到真实IP proxy_set_header X-Real-IP $remote_addr; # 真实端口号 proxy_set_header X-Real-Port $remote_port; # X-Forwarded-For 是一个 HTTP 扩展头部。 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 在多级代理的情况下，记录每次代理之前的客户端真实ip proxy_set_header HTTP_X_FORWARDED_FOR $remote_addr; # 获取到真实协议 proxy_set_header X-Forwarded-Proto $scheme; # 真实主机名 proxy_set_header Host $host; # 设置变量 proxy_set_header X-NginX-Proxy true; # 开启 brotli proxy_set_header Accept-Encoding \u0026#34;gzip\u0026#34;; } # 日志 access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; # 证书 ssl_certificate /etc/nginx/ssl/Bobby.cn.pem; ssl_certificate_key /etc/nginx/ssl/Bobby.cn.key; # curl https://ssl-config.mozilla.org/ffdhe2048.txt \u0026gt; /path/to/dhparam # ssl_dhparam /etc/nginx/ssl/dhparam; # HSTS (ngx_http_headers_module is required) (63072000 seconds) add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; # OCSP stapling ssl_stapling on; ssl_stapling_verify on; # verify chain of trust of OCSP response using Root CA and Intermediate certs # ssl_trusted_certificate /etc/nginx/ssl/all.sleele.com/fullchain.cer; # replace with the IP address of your resolver resolver 223.5.5.5; resolver_timeout 5s; } [root@Bobby ~]# docker exec -i nginx-proxy nginx -s reload 2.2 开启 redis 缓存 wordpress搭配redis加速网站访问速度\n2.3 搭配 jsdelivr-CDN 实现全站 cdn WordPress+jsDelivr开启伪全站CDN\n以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/wordpress-to-docker/","summary":"0 前言 本文参考以下链接: 从能用到好用-快速搭建高性能WordPress指南 前段时间着手开始搭建自己的 wordpress 博客，刚开始图方便直接买了阿里云的轻量应用服务器，它是一套预先搭建好的 lamp 架构，并已经做了一些初始化配置，直接访问 ip 就可以进行 wordpress 的安装和配置了。 这套 wordpress 的一个非常好的优点就是可以在阿","title":"wordpress | 迁移到 docker"},{"content":"1 七牛云配置 1.1 注册七牛云，新建存储空间 七牛云新用户有 10G 的免费空间，作为个人博客来说基本足够了\n1.2 为存储空间配置加速域名 1.3 配置 https 证书 1.3.1 购买免费证书 1.3.2 补全域名信息 1.3.3 域名验证 根据在域名提供商处新建解析\ndns 配置好之后等待 CA 机构审核后颁发证书就可以了\n1.4.4 开启 https 2 PicGo 配置 2.1 下载安装 下载链接：https://github.com/Molunerfinn/PicGo/releases/\n建议下载稳定版\n2.2 配置七牛云图床 ak 和 sk 在七牛云→个人中心→密钥管理中查看\n在 picgo 端配置各项信息，注意网址要改成 https\n3 typora 测试图片上传 下载地址：https://www.typora.io/\n在文件→偏好设置→图像中配置图片上传，选择安装好的 PicGo 的应用程序\n点击验证图片上传\n到七牛云存储空间看是否有这两个文件\ntypora 可以实现自动的图片上传，并将本地连接自动转换为外链地址\n4 可能的报错 一般报错原因都可在 picgo 的日志文件找到，路径：C:\\Users\\username\\AppData\\Roaming\\picgo\n4.1 failed to fetch 日志报错如下\n问题在于端口冲突，如果你打开了多个 picgo 程序，就会端口冲突，picgo 自动帮你把 36677 端口改为 366771 端口，导致错误。\n重新验证\n以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/typora-picgo-qiniu-upload-image/","summary":"1 七牛云配置 1.1 注册七牛云，新建存储空间 七牛云新用户有 10G 的免费空间，作为个人博客来说基本足够了 1.2 为存储空间配置加速域名 1.3 配置 https 证书 1.3.1 购买免费证书 1.3.2 补全域名信息 1.3.3 域名验证 根据在域名提供商处新建解析 dns 配置好之后等待 CA 机构审核后颁发证书就可以了 1.4.4 开启 https 2 PicGo 配置 2.1 下载安装 下载链接：http","title":"markdown 图片存储方案 | typora + picgo + 七牛云"},{"content":"1 现象 博客加载不出来我在七牛云的图片资源 使用浏览器直接访问图片 url 却是可以成功的 我将之前 csdn 的博客迁移到了 wordpress，图片外链地址就是 csdn 的，都可以正常加载。 使用浏览器直接访问图片 url 却是可以成功的\n我将之前 csdn 的博客迁移到了 wordpress，图片外链地址就是 csdn 的，都可以正常加载。\n2 排查 1、由于浏览器直接访问七牛云图床的 url 地址是可以访问的，证明地址并没错，有没有可能是 referer 防盗链的配置问题\n查看防盗链配置，并没有开\n2、wordpress 可以加载出来 csdn 的外链图片，期间也试了其他图床都是没问题的。\n3、看看七牛的图片外链和 csdn 的有何区别\n注意到七牛的图片外链是 http，当时嫌麻烦并没有配置 https，看来问题是出在这了\n因为我的网站配置了 ssl 证书，可能由于安全问题浏览器不予加载 http 项目，用 http 访问站点测试下图片是否可以加载\n访问成功了！\n3 解决 给图床服务器安装 ssl 证书，开启 https 访问，参考：typora-picgo-qiniu-upload-image\n以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/wordpress-load-image-failed/","summary":"1 现象 博客加载不出来我在七牛云的图片资源 使用浏览器直接访问图片 url 却是可以成功的 我将之前 csdn 的博客迁移到了 wordpress，图片外链地址就是 csdn 的，都可以正常加载。 使用浏览器直接访问图片 url 却是可以成功的 我将之前 csdn 的博客迁移到了 wordpress，图片外链地址就是 csdn 的，都可以正常加载。","title":"wordpress | 加载图片失败"},{"content":"默认主题下在后台设置里修改即可\ndux 主题修改方式：在后台管理→dux 主题编辑器→网站底部信息中添加\n\u0026lt;a href=\u0026#34;http://beian.miit.gov.cn/\u0026#34; rel=\u0026#34;external nofollow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;京ICP备2021023168号-1\u0026lt;/a\u0026gt; 通用修改方式\n在主题目录的 footer.php 文件中的 \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; 下添加代码\n\u0026lt;a href=\u0026#34;http://beian.miit.gov.cn/\u0026#34; rel=\u0026#34;external nofollow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;你的备案号\u0026lt;/a\u0026gt; 以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/wordpress-add-icp/","summary":"默认主题下在后台设置里修改即可 dux 主题修改方式：在后台管理→dux 主题编辑器→网站底部信息中添加 \u0026lt;a href=\u0026#34;http://beian.miit.gov.cn/\u0026#34; rel=\u0026#34;external nofollow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;京ICP备2021023168号-1\u0026lt;/a\u0026gt; 通用修改方式 在主题目录的 footer.php 文件中的 \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; 下添加代码 \u0026lt;a href=\u0026#34;http://beian.miit.gov.cn/\u0026#34; rel=\u0026#34;external nofollow\u0026#34; target=","title":"wordpress | 添加 icp 备案号"},{"content":"0 前言 本文参考以下链接:\n在 Apache 服务器上安装 SSL 证书 WordPress 强制跳转 https 教程 1 配置 ssl 证书 1、登录阿里云，选择产品中的 ssl 证书\n如果域名是阿里的他会自动创建 dns 解析，如果是其他厂商需要按照图片配置，等待几分钟进行验证\n点击审核，等待签发\n签发后根据需求下载所需证书\n我的 wordpress 是直接买的阿里轻量应用服务器，打开轻量应用服务器的控制台配置域名\n选择刚申请好的 ssl 证书\n在 wordpress 后台修改地址\n大功告成\n2 配置 https 强制跳转 一般站点需要在 httpd.conf 中的 \u0026lt;VirtualHost *:80\u0026gt; \u0026lt;/VirtualHost\u0026gt; 中配置重定向\nwordpress 不同，需要在伪静态文件（.htaccess）中配置重定向，无需在 httpd.conf 中配置\n2.1 修改伪静态文件（.htaccess） 伪静态文件一般在网页根目录，是一个隐藏文件\n在 #END Wordpress 前添加如下重定向代码，记得把域名修改成自己的\nRewriteEngine On RewriteCond %{HTTPS} !on RewriteRule ^(.*)$ https://Bobby.cn/%{REQUEST_URI} [L,R=301] 图中两段重定向代码略有不同\n第一段代码重定向触发器：当访问的端口不是 443 时进行重定向重定向规则：重定向到：https://{原域名}/{原 url 资源} 第二段代码重定向触发器：当访问的协议不是 TLS/SLL（https）时进行重定向重定向规则：重定向到：https://Bobby.cn/{原 url 资源} 第一段代码使用端口判断，第二段代码通过访问方式判断，建议使用访问方式判断，这样服务改了端口也可以正常跳转 第一段代码重定向的原先的域名，第二段代码可以把 ip 地址重定向到指定域名 2.2 测试 curl -I http://Bobby.cn 使用 http 访问站点的 80 端口成功通过 301 跳转到了 https\n以上\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/wordpress-ssl/","summary":"0 前言 本文参考以下链接: 在 Apache 服务器上安装 SSL 证书 WordPress 强制跳转 https 教程 1 配置 ssl 证书 1、登录阿里云，选择产品中的 ssl 证书 如果域名是阿里的他会自动创建 dns 解析，如果是其他厂商需要按照图片配置，等待几分钟进行验证 点击审核，等待签发 签发后根据需求下载所需证书 我的 wordpress 是直接买的阿里轻量应用服务器，打开轻","title":"wordpress | 配置免费 ssl 证书和 https 强制跳转"},{"content":"Github连接超时处理 2022-06-16 · bobby\n1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面这个\nC:\\Windows\\System32\\drivers\\etc\\ b.在host文件中加找到的ip做github.com的映射\n52.192.72.89\tgithub.com c.Windows系统需要重启DNS解析配置才会生效\nipconfig /flushdns 3、Linux系统配置 a. vim /etc/hosts增加获取到的代理ip\n52.192.72.89\tgithub.com 总结：获取到可ping通的代理地址后配置到hosts系统文件中，打开网页访问域名的时候会指向你配置的那个ip。Windows和Linux系统配置差不多，Windows需要重启下DNS解析。\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/github%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/","summary":"Github连接超时处理 2022-06-16 · bobby 1、通过以下地址获取速度较快的ip作为映射地址(需要在本地可以ping通的) https://ping.chinaz.com/github.com 2、Windows系统配置 a.打开host文件，路径一般是下面这个 C:\\Windows\\System32\\drivers\\etc\\ b.在host文件中加找到的ip做github.com的映射 52.192.72.89 github.com c.Windows系统需要重启DNS解析","title":""},{"content":"Hugo搭建手抄 2022-06-07 · bobby\nmd文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; caption: \u0026#34;\u0026#34; alt: \u0026#34;\u0026#34; relative: false #--- hugo操作命令 hugo -F --cleanDestinationDir 清除后生成public文件，可能会出现漏上传 hugo --buildDrafts 全部生成public git init git add . git commit -m \u0026#39;create blog\u0026#39; git remote add origin https://github.com/bobby-sheng/bobby-sheng.github.io.git git push -u origin master ##如果push失败，比如time out...可尝试下面的命令 git config --global http.sslVerify \u0026#34;false\u0026#34; git config --global --unset http.proxy git config --global --unset https.proxy #(2)之后再修改、更新博客 git add . git commit -m \u0026#39;add blogs\u0026#39; git push -u origin master bobby-sheng ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/hugo%E6%90%AD%E5%BB%BA%E6%89%8B%E6%8A%84/","summary":"Hugo搭建手抄 2022-06-07 · bobby md文件开端 #title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #date: {{ .Date }} #lastmod: {{ .Date }} #author: [\u0026#34;Sulv\u0026#34;] #categories: #- 分类1 #- 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等","title":""},{"content":"Pytest详解 2022-08-25 · bobby\n一、pytest概念 pytest是python的第三方测试框架，与python自带的unittest框架类似，但是比unittest框架要简洁，方便。\n二、pytest特点 pytest是非常成熟的测试框架，主要有一下几个特点\n1、非常容易上手，有丰富的文档\n2、可以通过skip跳过用例\n3、可以通过make标签区分用例并且可以通过make执行\n4、可以控制setup初始方法执行的对象是模块还是方法\n5、兼容unittest或者note框架\n6、支持执行部分用例\n7、支持通过pytest-cache缓存执行失败用例\n三、pytest安装 #python直接使用pip导入即可 pip install pytest 四、pytest 执行 #1、pytest可以通过指定文件目录，只执行该目录下的testcase #\t通过空格间隔多个文件。后面还可以在加一层make筛选 pytest test1 pytest test1 test2.py pytest 执行参数 -v 输出更详细的信息； -s 输入调试信息； -n 多线程 需要安装xdist库 -m 执行标签 --reruns 失败用例重跑 --html 生成简易报告 --last-failed --last-failed-no-failures all 基于失败缓存重跑，无缓存就执行全部 --alluredir ../allure-results allure报告存储地址 pytest -vs --reuns 2 #模板 pytest -v -s -l tempest -m make --last-failed --last-failed-no-failures all -n 14 --reruns 0 --show-capture=stderr --dist=loadfile --durations=30 --alluredir ../allure-results pytest make执行（-m） #2、pytest make执行（-m） @pytest.mark.smoke def aa(): pass 执行：pytest test1 -m smoke pytest 执行顺序 #pytest顺序执行，需要给用例写上make装饰器方法 @pytest.make.run(order=1) def aa(): pass 五、pytest setup初始 #pytest框架在执行用例时的初始化分为了4个层面 1、模块级：setup_module/teardown_module #每个.py文件中存在就会执行一次 2、函数级：setup_function/teardown_function #函数可以理解为不在calss类种的def方法，使用每个函数都会执行 3、类级:setup_class/teardown_class #class类只执行一次 4、方法级：setup_method/teardown_method #class类中的def方法每个def都会执行 六、@pytest.fixture初始 #@pytest.fixture()和setup类似，都是初始方法，不过是以装饰器的形式去使用 #@pytest.fixture(scope=\u0026#34;作用域\u0026#34;, params=\u0026#34;数据驱动\u0026#34;,autouse=\u0026#34;自动执行\u0026#34;,ids=\u0026#34;参数别名\u0026#34;,name=\u0026#34;fixture别名\u0026#34;) 1、模块级：@pytest.fixture(scope=\u0026#34;session\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #多个py文件可以调用一次，存放在conftest.pyw文件中，作用域不同 2、模块级：@pytest.fixture(scope=\u0026#34;module\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #每个.py文件中存在就会执行一次 3、函数级：@pytest.fixture(scope=\u0026#34;function\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #函数可以理解为不在calss类种的def方法，使用每个函数都会执行，如果scope参数为空默认为此 4、类级:@pytest.fixture(scope=\u0026#34;class\u0026#34;,autouse=\u0026#34;ture\u0026#34;) #class类只执行一次 #fixture中存在下级可以调用上级，上级无法向下兼容，可以做到流程管理，举例：module可以调用session,需要配conftest.py文件中，每个子级文件都可以创建conftest.py文件，作用域不同。可以存放登录、清理资源等方法。 七、@pytest ddt参数传递 pytest .mark.parametrize()\n#pytest 内置装饰器 @pytest.mark.parametrize 可以让测试数据参数化，把测试数据单独管理，类似 ddt 数据驱动的作用，方便代码和测试数据分离。 @pytest.mark.parametrize(\u0026#39;x,y\u0026#39;,[(1,2),(3,4)]) def test_sum(x,y): sum = x + y print(sum) if __name__ ==\u0026#34;__main__\u0026#34;:python pytest.main([\u0026#39;test_sample.py\u0026#39;,\u0026#39;-s\u0026#39;]) 3 7 八、pytest断言 #常用断言，用的是python自带的断言。这块应该没有unittest好用 assert xx 判断xx为真 assert not xx 判断xx不为真 assert a in b 判断b包含b assert a==b 判断等于b assert a!=b 判断a不等于b #异常断言 pytest.rauses。详细断言异常 def test_zero_division_long(): with pytest.raises(ZeroDivisionError) as excinfo: 1 / 0 # 断言异常类型 type assert excinfo.type == ZeroDivisionError # 断言异常 value 值 assert \u0026#34;division by zero\u0026#34; in str(excinfo.value) #封装的unittest异常断言 self.assertRaises( lib_exc.NotFound, self.aaa, **kwagr) 九、pytest.ini #ini文件需要放在项目根目录中。可以把一些命令参数填写进去，也可以忽略告警、设置固定时间、以及写入make不提示告警 [pytest] addopts = -rsxX -l -strict --tb=short addopts后面可以接pytest运行时的参数，执行时就不需要填写参数了 addopts = -p no:warnings 忽略告警 env = PYTHONHASHSEED=0 并发执行用例时程序线程之间的数量不相等导致报错，可以使用这个命令 timeout = 2400 需要导入pytest_timeout插件，每条用例不包含前置执行时间超过2400s直接停止报错。控制执行时间 markers = skipcase mistake secret 写入make，不会告警 #pytest.ini还有很多参数，我只用到这些部分，记录一下 十、pytest_allure 安装命令：pip install allure-pytest 使用方法\t参数值\t参数说明 @allure.epic()\tepic描述\t敏捷里面的概念，定义史诗，往下是feature @allure.feature()\t模块名称\t功能点的描述，往下是story @allure.story()\t用户故事\t用户故事，往下是title @allure.title(用例的标题)\t用例的标题\t重命名html报告名称 @allure.testcase()\t测试用例的链接地址\t对应功能测试用例系统里面的case @allure.issue()\t缺陷\t对应缺陷管理系统里面的链接 @allure.description()\t用例描述\t测试用例的描述 @allure.step()\t操作步骤\t测试用例的步骤 @allure.severity()\t用例等级\tblocker，critical，normal，minor，trivial @allure.link()\t链接\t定义一个链接，在测试报告展现 @allure.attachment()\t附件\t报告添加附件 #1、生成报告本地是获取本地文件，使用命令生成。allure generate allure(生成的allure报告文件名) allure open allure-report（打开html报告） #2、jenkins是在宿主机安装pip3 install allure-pytest或者在docker中安装pip3 install allure-pytest。安装完成后在jenkins安装插件，配置好，使用shell命令 pytest --alluredir ./report生成。详细可以看： #https://www.icode9.com/content-4-828260.html 总结 pytest还有很多自带的装饰器以及第三方插件，我这里写的只是冰山一角，这些足够平时的工作。下次遇见再补充上来。\n相比较于unittest框架还是好用的，下面例举一点优缺点\n1、测试报告不同 unittest支持 HTMLTestRunner BeautifulRepor pytest 支持 allure 2、前置不同 unittest前置只有两种，setup与setupclass pytest有两种方法，5中作用域 3、断言不同 unittest使用断言是self.assertinto() pytest是python自带的断言，直接使用 assert 4、用例收集不同 unittest需要自己手动写代码收集测试套件 pytest自动收集 5、并发不同 unittest无并发插件，需要手动写并发多线程 pytest有并发插件 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/pytest%E8%AF%A6%E8%A7%A3/","summary":"Pytest详解 2022-08-25 · bobby 一、pytest概念 pytest是python的第三方测试框架，与python自带的unittest框架类似，但是比unittest框架要简洁，方便。 二、pytest特点 pytest是非常成熟的测试框架，主要有一下几个特点 1、非常容易上手，有丰富的文档 2、可","title":""},{"content":"Python元组详解 2022-07-27 · bobby\n一、元组和列表的区别 1、元组无法增删改查，只能通过重新赋值修改元素，可以把元组理解为只可读的列表\n2、元组占用内存比列表小，python程序缓存机制对于静态资源占用内存较小的会留缓存，新建相同内存大小的元组时可以从缓存中获取，列表就需要从操作系统寻找内存，速度会快很多\n3、元组可以在映射（和集合的成员）中当做“键”使用，而列表不行\n二、元组的基本使用 1、tuple函数的使用 # tuple函数的功能与list函数基本上是一样的：以一个序列作为参数并把它转化为元组。如果参数就是元组，那么该函数就会被原样返回： \u0026gt;\u0026gt;\u0026gt; tuple([1,2,3]) (1, 2, 3) \u0026gt;\u0026gt;\u0026gt; tuple(\u0026#39;abc\u0026#39;) (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) \u0026gt;\u0026gt;\u0026gt; tuple((1,2,3)) (1, 2, 3) #可以通过转为元组，再转为列表，做一些字符串的处理 3、索引 # tuple之索引取值 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) # name_tuple[0] = \u0026#39;nick handsom\u0026#39; # 报错 print(name_tuple[0]) #nick 4、切片 # tuple之切片 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple[1:3:2])#jason 5、长度 # tuple之切片 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print len(name_tuple)#4 6、成员运算 # tuple之成员运算 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(\u0026#39;nick\u0026#39; in name_tuple) #True 7、循环 # tuple之循环 name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) for name in name_tuple: print(name) 8、统计值个数count() # tuple之count() name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple.count(\u0026#39;nick\u0026#39;): )#1 7、返回值的索引位置-index(值) # tuple之index() name_tuple = (\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;) print(name_tuple.index(\u0026#39;nick\u0026#39;): )#0 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%85%83%E7%BB%84%E8%AF%A6%E8%A7%A3/","summary":"Python元组详解 2022-07-27 · bobby 一、元组和列表的区别 1、元组无法增删改查，只能通过重新赋值修改元素，可以把元组理解为只可读的列表 2、元组占用内存比列表小，python程序缓存机制对于静态资源占用内存较小的会留缓存，新建相同内存大小的元组时可以从缓存中获取，列表就需要从操作系统寻找内存，","title":""},{"content":"Python列表方法详解 2022-07-21 · bobby\n笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。\n一、列表常用方法 1、索引取值-list[index] 按索引取值（正向取值+反向取值），即可存也可以取\n# list之索引取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list[0] = \u0026#39;nick handsom\u0026#39; 存入到第一个索引位置中 # name_list[1000] = \u0026#39;tank sb\u0026#39; # 报错 #\u0026#34;nick handsom\u0026#34; pring name_list[0] 2、切片 切片操作基本表达式：[start_index：stop_index：step] start 值\n2.1、获取单个元素 list =[\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] #red print(list[0]) # black print(list[-1]) 2.2、获取列表对象 list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 从左往右获取索引,[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[:]) print(list[::]) print(list[::1]) \u0026#39;\u0026#39;\u0026#39; 从右往左获取索引（反向索引）,[\u0026#39;black\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] \u0026#39;\u0026#39;\u0026#39; print(list[::-1]) 2.3、获取列表部分的值 （1）正向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; # 正向索引：start_index为0到end_index为6 print(list[0:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # start_index没有填写，默认从第一个开始,一直取到end_index=6 print(list[:6]) # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step没有填写，默认是1，start_index为0,一直取到end_index=2 print(list[0:2]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;] # step没有填写，默认是1，start_index为1,一直取到end_index=4 print(list[1:4]) # [\u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;] # start_index为1,一直取到end_index=5，step是2 print(list[1:5:2]) # [\u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;] （2）反向索引\nlist = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 反向索引：step为负数 \u0026#39;\u0026#39;\u0026#39; print(\u0026#34;反向索引=============\u0026#34;) # step=1，反向索引，从start_index=-6开始，一直取到end_index=0为止。 print(list[-6::]) #[\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=3开始，一直取到end_index=0为止。 print(list[3:0:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] # step=-2，反向索引，从start_index=6开始，一直取到end_index=0为止。 print(list[6::-2]) #[\u0026#39;black\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] # step=-3，反向索引，从start_index=5开始，一直取到end_index=2为止。 print(list[5:2:-3]) #[\u0026#39;black\u0026#39;] # step=-1，反向索引，从start_index=-3开始，一直取到end_index=-5为止。 print(list[-3:-5:-1]) #[\u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;] # start_index \u0026gt; end_index时，取出的结果为空 print(list[4:2]) #[] print(list[-5:-3:-1]) # [] 2.4、列表多层切片 \u0026#39;\u0026#39;\u0026#39;多层切片\u0026#39;\u0026#39;\u0026#39; list = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;white\u0026#34;,\u0026#34;black\u0026#34;] # 链式列表切片 print(list[:6][2:5][-1:]) \u0026#39;\u0026#39;\u0026#39;上边的链式列表与下边的步骤是相等的\u0026#39;\u0026#39;\u0026#39; list2 = list[:6] # [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;, \u0026#39;black\u0026#39;] print(list2) list3 = list2[2:5] # [\u0026#39;blue\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;white\u0026#39;] print(list3) list4 = list3[-1:] # [\u0026#39;white\u0026#39;] print(list4) 3、长度-len(list) # list之长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 4 print(len(name_list)) # list之多维列表长度 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]] # 3 print(len(name_list[4])) 4、成员运算in和not in # list之成员运算in和not in name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] #False print(\u0026#39;tank sb\u0026#39; in name_list) #Ture print(\u0026#39;nick handsome\u0026#39; not in name_list) 5、追加值-append（值） # list之追加值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.append(\u0026#39;tank sb\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 6、删除值-del list[index] # list之删除值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] del name_list[2] #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#39;tank sb\u0026#39;] print name_list 7、列表循环取值 # list之列表循环取值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] 第一种：for name in name_list: print(name) 第二种：li=[i for i in name_list] 二、列表内置方法 1、列表插入-insert(index) #使用方法insert(index,list) #注意：如果索引超出范围,则如果索引为正,则该项目将追加到末尾；如果索引为负,则将其追加到开头，没有例外. \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(5, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;item\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; my_list.insert(-3, \u0026#39;item\u0026#39;) \u0026gt;\u0026gt;\u0026gt; my_list [\u0026#39;item\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 2、列表删除-pop(index) #使用方法 list.pop(),index为空默认删除最后一个值[-1] #注意：此方法会返回删除数据的值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.pop(1) #[\u0026#39;nick\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print(name_list) 3、列表删除-remove(值) # 使用方法list.remove(值),会删除匹配到的第一个值 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.remove(\u0026#39;jason\u0026#39;) #[\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list 4、列表重复值统计-count(值) # 使用方法list.count(值),会统计列表中值的个数 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 2 print name_list.count(\u0026#39;jason\u0026#39;) 5、列表值的索引位置-index(值) # 使用方法list.index(值),会查找出列表中匹配到的第一个值的位置 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] # 1 print name_list.index(\u0026#39;jason\u0026#39;) 6、列表清除内容-clear() # 使用方法list.clear(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.clear() # [] print name_list 7、列表复制-copy() # 使用方法list.copy(),清除列表内容 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=name_list.copy() # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] print name_list_copy 8、列表合并-extend(list2) # 使用方法list1.extend(list2),合并两个值列表为一个 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list_copy=[\u0026#34;nick_aaaa\u0026#34;] name_list.extend(name_list_copy) # [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;,\u0026#34;nick_aaaa\u0026#34;] print name_list 9、列表反转-reverse() # 使用方法list.reverse(),列表反转 name_list = [\u0026#39;nick\u0026#39;, \u0026#39;jason\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;tank\u0026#39;, \u0026#39;sean\u0026#39;] name_list.reverse() # [\u0026#39;sean\u0026#39;, \u0026#39;tank\u0026#39;, \u0026#39;jason\u0026#39;,\u0026#39;jason\u0026#39;, \u0026#39;nick\u0026#39;] print name_list 10、列表排序-sort() # 使用方法list.sort(),使用sort列表的元素必须是同类型的 #列表内的元素，按照由小到大顺序进行排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort() # [3, 9, 10, 12, 32, 45, 56, 89, 100] print(list_val) #列表内的元素，按照由大到小顺序排序。 list_val = [12,32,9,89,10,3,100,45,56] list_val.sort(reverse=Ture) # [100, 89, 56, 45, 32, 12, 10, 9, 3] print(list_val) ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","summary":"Python列表方法详解 2022-07-21 · bobby 笔记背景 好记性不如烂笔头，在需要的时经常断片忘记基础方法，写这笔记目的一是加深印象，二是实在记不得也不需要去外网寻找找影响效率。 一、列表常用方法 1、索引取值-list[index] 按索引取值（正向取值+反向取值），即可存也可以取 # list之索引取值 name_list","title":""},{"content":"Python字典详解 2022-07-26 · bobby\n一、字典常用方法 字典是Python中重要的数据类型，字典是由\u0026quot;键-值\u0026quot;对组成的集合，“键-值\u0026quot;对之间用逗号隔开，包含在一对花括号中。字典中的\u0026quot;值\u0026quot;通过\u0026quot;键\u0026quot;来引用。\n1、定义 #第一种 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #第二种 bobby = dict{1 = \u0026#34;a\u0026#34;,0 = \u0026#34;b\u0026#34;} print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} 2、2种获取字典的value方法 2.1、dict[key] 通过key值获取相应的value值\nbobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby[1] #a 2.1、dict.get(key[,default_value]) 参数key表示字典的键值，参数default_value可以作为get()的返回值，默认值为None。如果指定default_value参数值，表示如果参数key键值在字典key列表中，则返回对应的value值，如果不在，则返回预先设定的default_value的值\n# default_value参数可以作为未找到value的返回值，默认返回空 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #有值情况返回值 print bobby.get(1, \u0026#34;ppp\u0026#34;) #a #无值情况返回自定义值 print bobby.get(4, \u0026#34;ppp\u0026#34;) #ppp #无自定义值且找不到值的情况默认返回空 print bobby.get(4) #None 3、2种添加字典元素方法 3.1、dict[key] = value 如果键值key不在字典dict的key列表中，字典dict添加（key：value）的记录。如果已经在key列表中，则修改键值key对应的value值\nbobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} bobby[3] = \u0026#34;c\u0026#34; print bobby #{0: \u0026#39;b\u0026#39;, 1: \u0026#39;a\u0026#39;, 3: \u0026#39;c\u0026#39;} #如果已经在key列表中，则修改键值key对应的value值。 bobby[1] = \u0026#34;c\u0026#34; print bobby #{0: \u0026#39;b\u0026#39;, 1: \u0026#39;c\u0026#39;} 3.2、dict.setdefault(key[,default_value]) 如果索引key在字典key列表中，则返回对应的value值，如果不在key列表中，则添加新索引key和value在字典中，并反馈default_value值，默认值 为None\n#当key存在时，会返回存在的value，并且不修改 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(1) #a print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} #当key不存在时，则添加新索引key和value在字典中，并反馈 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(4，\u0026#34;c\u0026#34;) #c print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;,4:\u0026#39;c\u0026#39;} #当key不存在时，default_value为空，默认填入null bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.setdefault(4) #null print bobby #{1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;,4:\u0026#39;null\u0026#39;} 4、获取字典所有keys、Values或者key-valu键值对 #获取字典的所有\u0026#34;键\u0026#34;-\u0026#34;值\u0026#34;元素。通过调用字典的items()方法实现，返回的是(key,value)元组组成的列表 #python2中取出的是列表（鸡蛋）；python3中取出的是元组（鸡） bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.items() #[(0, \u0026#39;b\u0026#39;), (1, \u0026#39;a\u0026#39;)] #获取所有key,返回列表 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.key() #[0, 1] #获取所有Values,返回列表 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.Values() #[\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;] 5、循环 # dic之循环 # dic是无序的，但是python3采用了底层优化算法，所以看起来是有序的，但是python2中的字典是无序 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} for k, v in bobby.items(): print(k, v) #(0, \u0026#39;b\u0026#39;) (1, \u0026#39;a\u0026#39;) # items可以换成keys()、values() 6、3种删除字典内容方法 6.1 del dict[key] #调用py内置方法del bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} del bobby[1] print bobby #{0: \u0026#39;b\u0026#39;} 6.2 dict.pop(key[,default_value]) pop()函数必须指定参数索引key才能删除对应的值。如果索引key在字典key列表中，则返回索引key对应的value值。如果不存在，则返回预先设置的default_value值，如果未设置，会爬出KeyError异常信息\n#索引key在字典key列表中，则返回索引key对应的value值 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(1) #a print bobby #{0: \u0026#39;b\u0026#39;} #索引key不在字典key列表中，未设置返回值，会直接报错 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(3) #KeyError: 3 #索引key在字典key列表中，设置返回值，会返回设置值或者提示 bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} print bobby.pop(3,\u0026#34;null\u0026#34;) #null print bobby {0: \u0026#39;b\u0026#39;, 1: \u0026#39;a\u0026#39;} 6.3 dict.clear() #调用py内置方法del bobby = {1: \u0026#39;a\u0026#39;, 0: \u0026#39;b\u0026#39;} bobby.clear() print bobby #{} 7、多个key设值-fromkeys([key,],values) # dic之fromkeys() dic = dict.fromkeys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;sex\u0026#39;], None) print dic #{\u0026#39;name\u0026#39;: None, \u0026#39;age\u0026#39;: None, \u0026#39;sex\u0026#39;: None} 8、两字典合并-1.update(2) # dic之update() dic1 = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} dic2 = {\u0026#39;c\u0026#39;: 3} dic1.update(dic2) print(dic1) #dic1: {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 9、字典排序-sorted() dict = {\u0026#39;2\u0026#39;:\u0026#34;Python\u0026#34;,\u0026#39;1\u0026#39;:\u0026#34;Java\u0026#34;,\u0026#39;3\u0026#39;:\u0026#34;C++\u0026#34;} sorted(dict.items(),key=lambda d:d[0]) #[(\u0026#39;1\u0026#39;, \u0026#39;Java\u0026#39;), (\u0026#39;2\u0026#39;, \u0026#39;Python\u0026#39;), (\u0026#39;3\u0026#39;, \u0026#39;C++\u0026#39;)] sorted(dict.items(),key=lambda d:d[1]) #[(\u0026#39;3\u0026#39;, \u0026#39;C++\u0026#39;), (\u0026#39;1\u0026#39;, \u0026#39;Java\u0026#39;), (\u0026#39;2\u0026#39;, \u0026#39;Python\u0026#39;)] #也可以使用如下方法对值进行排序，先使用zip进行反转 sorted(zip(prices.values(),prices.keys())) #[(10.75, \u0026#39;FB\u0026#39;), (37.2, \u0026#39;HPQ\u0026#39;), (45.23, \u0026#39;ACME\u0026#39;), #(205.55, \u0026#39;IBM\u0026#39;), (612.78, \u0026#39;AAPL\u0026#39;)] #说明:如果存在values相同的情况下，则会按照key的大小进行排序。如下： prices = {\u0026#39;ACME\u0026#39;: 45.23, \u0026#39;AAPL\u0026#39;: 612.78, \u0026#39;IBM\u0026#39;: #612.78, \u0026#39;HPQ\u0026#39;: 37.20,\u0026#39;FB\u0026#39;: 10.75 } sorted(zip(prices.values(),prices.keys())) #[(10.75, \u0026#39;FB\u0026#39;), (37.2, \u0026#39;HPQ\u0026#39;), (45.23, \u0026#39;ACME\u0026#39;), (612.78, \u0026#39;AAPL\u0026#39;), (612.78, \u0026#39;IBM\u0026#39;)] 10、成员运算in和not in # dic之成员运算in和not in,只会判断key是否存在 dic = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} print(\u0026#39;a\u0026#39; in dic) #True print(1 in dic) #False 11、获取字典相同元素 #获取两个字典相同的键、值或者items。可以通过集合运算的方式获取。 dic_a = {\u0026#39;x\u0026#39;:1,\u0026#39;y\u0026#39;:2,\u0026#39;z\u0026#39;:3} dic_b = {\u0026#39;w\u0026#39;:10,\u0026#39;x\u0026#39;:11,\u0026#39;y\u0026#39;:2} dic_a.keys() \u0026amp; dic_b.keys() #{\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;} dic_a.keys() - dic_b.keys() #{\u0026#39;z\u0026#39;} dic_a.items() \u0026amp; dic_a.items() #{(\u0026#39;z\u0026#39;, 3), (\u0026#39;x\u0026#39;, 1), (\u0026#39;y\u0026#39;, 2)} ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%AD%97%E5%85%B8%E8%AF%A6%E8%A7%A3/","summary":"Python字典详解 2022-07-26 · bobby 一、字典常用方法 字典是Python中重要的数据类型，字典是由\u0026quot;键-值\u0026quot;对组成的集合，“键-值\u0026quot;对之间用逗号隔开，包含在一对花括号中。字典中的\u0026quot;值\u0026quot;通过\u0026quot;键\u0026quot;来引用。 1、定义 #第一种 bobby =","title":""},{"content":"Python字符串详解 2022-07-25 · bobby\n一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;切片3-最后: {msg[3:]}\u0026#39;) print(f\u0026#39;切片3-8: {msg[3:8]}\u0026#39;) print(f\u0026#39;切片3-8，步长为2: {msg[3:8:2]}\u0026#39;) print(f\u0026#39;切片3-最后，步长为2: {msg[3::2]}\u0026#39;) # 了解，步长为正从左到右；步长为负从右到左 print(\u0026#39;\\n**了解知识点**\u0026#39;) print(f\u0026#39;切片所有: {msg[:]}\u0026#39;) print(f\u0026#39;反转所有: {msg[::-1]}\u0026#39;) print(f\u0026#39;切片-5--2: {msg[-5:-2:1]}\u0026#39;) print(f\u0026#39;切片-2--5: {msg[-2:-5:-1]}\u0026#39;) 3、长度-len(str) msg=\u0026#34;bobby\u0026#34; #5 print len(msg) 4、成员运算in和not in msg=\u0026#34;bobby\u0026#34; #True print \u0026#34;b\u0026#34; in msg #False print \u0026#34;k\u0026#34; in msg 5、移除前后空白或字符-str.strip(“值”) #去除字符串开头和结尾处指定的字符(默认为空格或换行符)或字符序列，不会去除字符串中间对应的字符。 msg=\u0026#34; bobby \u0026#34; #bobby print msg.strip() #bobby msg=\u0026#34;*#$bobby+\u0026#34; print msg.strip(\u0026#34;*#$+\u0026#34;) 6、切割左到右，与右到左切割-str.split(“值”)和str.rsplit(“值”) #方法通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为空字符，包括空格，换行（\\n）,制表符（\\t）等 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;,‘222’] print msg.split() msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39;bobby\u0026#39;, \u0026#39;jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;) #左右切割用法一致，在不控制切割第几个字符的情况下返回值都是一样的，控制切割后结果才会不一样 msg = \u0026#34; bobby:jkkjjkkj:llll\u0026#34; # [\u0026#39; bobby\u0026#39;, \u0026#39;jkkjjkkj:llll\u0026#39;] # [\u0026#39; bobby:jkkjjkkj\u0026#39;, \u0026#39;llll\u0026#39;] print msg.split(\u0026#34;:\u0026#34;,1) print msg.rsplit(\u0026#34;:\u0026#34;,1) 7、循环-for #for 循环取值 msg = \u0026#34; bobby jkkjjkkj\\nllll\\t222\u0026#34; for i in msg: print i 二、字符串需要掌握内置方法 1、去除字符串左右两边空格或指定字符-str.lstrip(“值”)和str.rstrip(“值”) #lstrip()用于去除字符串左边的空格或指定字符 #rstrip()用于去除字符串右边的空格或指定字符。 #lstrip和rstrip去除字符串原理与strip相同，只不过lstrip只从左侧进行匹配去除，rstrip只从右侧进行匹配去除 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #bobby\u0026amp;\u0026amp;\u0026amp; #***bobby print msg.lstrip(\u0026#34;*\u0026#34;) print msg.rstrip(\u0026#34;\u0026amp;\u0026amp;\u0026#34;) 2、字符串转换大小写–str.upper()和str.lower() #lower()小写，upper()大写 msg = \u0026#34;***bobby\u0026amp;\u0026amp;\u0026amp;\u0026#34; #***bobby\u0026amp;\u0026amp;\u0026amp; #***BOBBY\u0026amp;\u0026amp;\u0026amp; print msg.lower() print msg.upper() 3、对比字符串开头结尾值-startswith(“值”)和endswith(“值”) msg = \u0026#34;bobbysheng\u0026#34; #True #True print msg.startswith(\u0026#34;bobby\u0026#34;) print msg.endswith(\u0026#34;sheng\u0026#34;) 4、连接列表中的字符串-\u0026quot; “.join(list) #把列表值全部拆出来，填充上指定的值。与split切割方方法完全相反 #join将 容器对象 拆分并以指定的字符将列表内的元素(element)连接起来，返回字符串（注：容器对象内的元素须为字符类型） li = [\u0026#39;my\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;bob\u0026#39;] s = [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] # my name is bob # my_name_is_bob print \u0026#39; \u0026#39;.join(li) print \u0026#39;_\u0026#39;.join(li) #可以通过split方法把join填充的值全部复原为一个列表 li_join=\u0026#34;my_name_is_bob\u0026#34; # [\u0026#39;my\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;bob\u0026#39;] print li_join.split(\u0026#34;_\u0026#34;) 5、替换字符串-str.replace(old, new[, max]) #把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 str = \u0026#34;this is string example....wow!!! this is really string\u0026#34; #thwas was string example....wow!!! thwas was really string #thwas was string example....wow!!! thwas is really string print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;) print str.replace(\u0026#34;is\u0026#34;, \u0026#34;was\u0026#34;, 3) 6、检测字符串是否只由数字组成-str.isdigit() #如果字符串包含的是数字类型则返回 True 否则返回 False。 str = \u0026#34;111\u0026#34; str_false = \u0026#34;111.2\u0026#34; #True print str.isdigit() #False print str_false.isdigit() 7、字符串find()、rfind()、index()、rindex()、count() # find()、rfind()、index()、rindex()、count() msg = \u0026#39;my name is tank, tank shi sb, hha\u0026#39; #11 #-1 #17 #11 #17 #2 print msg.find(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.find(\u0026#39;tank\u0026#39;,0,3) # 找不到返回-1 print msg.rfind(\u0026#39;tank\u0026#39;) # 找不到返回-1 print msg.index(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.rindex(\u0026#39;tank\u0026#39;) # 找不到报错 print msg.count(\u0026#39;tank\u0026#39;) 8、字符串添加内容center()、ljust()、rjust()、zfill() center,ljust,rjust,zfillcenter：在center内容中间添加内容 print(\u0026#39;egon\u0026#39;.center(50,\u0026#39;*\u0026#39;)) ***********************egon*********************** ljust：在ljust内容左边添加内容 print(\u0026#39;egon\u0026#39;.ljust(50,\u0026#39;*\u0026#39;)) egon********************************************** rjust：在ljust内容右边添加内容 print(\u0026#39;egon\u0026#39;.rjust(50,\u0026#39;*\u0026#39;)) **********************************************egon zfill：在zfill内容中加到指定个数 print(\u0026#39;egon\u0026#39;.zfill(10)) 000000egon 9、字符串设置制表符代表的空格数str.expandtabs() #expandtabs()方法返回一个字符串的副本，其中tab字符。使用空格扩展’\\t‘，可选地使用给定的制表符大小 - tabize(默认值为8)。 expandtabs 设置制表符代表的空格数 msg=\u0026#39;hello\\tworld\u0026#39; print(msg.expandtabs(2)) # 设置制表符代表的空格数为2 hello world 10、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 11、字符串captalize()、swapcase()、title() captalize：一段字符串的首个字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.capitalize()) Hello world egon swapcase：一段字符串的首个字母小写，其余大写 print(\u0026#34;Hello WorLd EGon\u0026#34;.swapcase()) hELLO wORlD egON title：每个单词的首字母大写，其余小写 print(\u0026#34;hello world egon\u0026#34;.title()) Hello World Egon 12、is系列，判断字符串是否属于此格式 1、.isdigit()：判断是否全部都是纯数字类型 print(\u0026#39;123\u0026#39;.isdigit()) True 2、.islower()：判断是否全部都是小写字母 print(\u0026#39;abc\u0026#39;.islower()) True 3、.isupper()：判断是否全部都是大写字母 print(\u0026#39;ABC\u0026#39;.isupper()) True 4、.istitle()：判断是否是单词首个字母大写 print(\u0026#39;Hello World\u0026#39;.istitle()) True/5、.isalnum()：判断是否由数字或字母组成 print(\u0026#39;123123aadsf\u0026#39;.isalnum()) # 字符串由字母或数字组成结果为True True 6、.isalpha()：判断是否全部由字母构成 print(\u0026#39;ad\u0026#39;.isalpha()) # 字符串由由字母组成结果为True True 7、.isspace()：判断是否全部由空格构成 print(\u0026#39; \u0026#39;.isspace()) # 字符串由空格组成结果为True True 8、.isidentifier()：判断是否可以定义为变量名 print(\u0026#39;print\u0026#39;.isidentifier()) print(\u0026#39;age_of_egon\u0026#39;.isidentifier()) print(\u0026#39;1age_of_egon\u0026#39;.isidentifier()) True True False # 变量名不能以数字开头 13、数字系列的识别 先定义表示同一个数字的4个不同方法： num1=b\u0026#39;4\u0026#39; #bytes num2=u\u0026#39;4\u0026#39; #unicode,python3中无需加u就是unicode num3=\u0026#39;四\u0026#39; #中文数字 num4=\u0026#39;Ⅳ\u0026#39; #罗马数字 isdigit只能识别：num1、num2 print(num1.isdigit()) # True print(num2.isdigit()) # True print(num3.isdigit()) # False print(num4.isdigit()) # False True True False False isnumberic可以识别：num2、num3、num4 print(num2.isnumeric()) # True print(num3.isnumeric()) # True print(num4.isnumeric()) # True True True True isdecimal只能识别：num2 print(num2.isdecimal()) # True print(num3.isdecimal()) # False print(num4.isdecimal()) # False True False False ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3/","summary":"Python字符串详解 2022-07-25 · bobby 一、字符串常用方法 1、索引-str[0] #从0开始 msg=\u0026#34;bobby\u0026#34; #b print msg[0] 2、切片-str[:::] # 索引切片 msg = \u0026#39;hello nick\u0026#39; # 0123456789 # 索引序号 print(f\u0026#39;切片3-最后: {msg[3:]}\u0026#39;) print(f\u0026#39;切片3-8: {msg[3:8]}\u0026#39;) print(f\u0026#39;切片3-8，步长为2: {msg[3:8:2]}\u0026#39;) print","title":""},{"content":"python文档读写方法 2022-07-14 · bobby\n一、文档读写实用方法 1、readline()函数\n解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、readlines()函数\nfile.readline()[index]\n解释：此函数把文件作列表全部读取出来，可通过for循环获取每一行的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): print i 2、read()函数\n解释：此函数把文件样式原封不动的打印出来\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.read() print rows 二、打开文件模式解释 ### 常用模式打开文件 # 1.r模式 # 2.w模式:写入的文件不存在会自动创建，每一次写入都会覆盖前面的内容 # 3.a模式：与w模式一样，但是内容会追加 # 4.b模式：字节读取+字节写入 ### 其他模式模式 # 1.r+--打开文件用于读写，文件指针会放在文件开头 # 2.rb+--二进制打开文件用于读写，文件指针会放在文件开头 # 3.w+--打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 4.wb+--二进制打开文件用于读写，并且从头开始编辑，会覆盖原内容 # 5.ab--二进制打开用于追加，指针放末尾，只能写 # 6.ab+--二进制打开文件用于追加，指针放末尾 # 7.a+--打开文件读写，指针放末尾，文件存在追加模式，不存在新建 三、文件读写案例 案例一\n解释：打开文件，获取文件所在行之后，赋值。在打开文件写入变量中的值\nwith open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i, line in enumerate(rows): if content[3] in line: a = i for k in range(a, a+60): if \u0026#34;expect_return = \u0026#34; in rows[k]: rows[k] = \u0026#34; expect_return =\u0026#34; + content[2] break log.info(\u0026#34;写入\u0026#34;) with open(p, \u0026#39;w+\u0026#39;) as w: w.writelines(rows) 案例二\n解释：一次性打开多个文件，实现文件的快速拷贝。\nwith open(\u0026#39;32.txt\u0026#39;, \u0026#39;rb\u0026#39;) as fr, \\ open(\u0026#39;35r.txt\u0026#39;, \u0026#39;wb\u0026#39;) as fw: f.write(f.read()) 案例三\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr, \\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: data = fr.read() # 全部读入内存,如果文件很大,会很卡 data = data.replace(\u0026#39;tank\u0026#39;, \u0026#39;tankSB\u0026#39;) # 在内存中完成修改 fw.write(data) # 新文件一次性写入原文件内容 # 删除原文件 os.remove(\u0026#39;37r.txt\u0026#39;) # 重命名新文件名为原文件名 os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 案例四\nimport os with open(\u0026#39;37r.txt\u0026#39;) as fr,\\ open(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;w\u0026#39;) as fw: # 循环读取文件内容，逐行修改 for line in fr: line = line.replace(\u0026#39;jason\u0026#39;, \u0026#39;jasonSB\u0026#39;) # 新文件写入原文件修改后内容 fw.write(line) os.remove(\u0026#39;37r.txt\u0026#39;) os.rename(\u0026#39;37r_swap.txt\u0026#39;, \u0026#39;37r.txt\u0026#39;) print(\u0026#39;done...\u0026#39;) 四、总结 修改文件内容的思路为：以读的方式打开原文件，以写的方式打开一个新的文件，把原文件的内容进行修改，然后写入新文件，之后利用os模块的方法，把原文件删除，重命名新文件为原文件名，达到以假乱真的目的\n","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E6%96%87%E6%A1%A3%E8%AF%BB%E5%86%99%E6%96%B9%E6%B3%95/","summary":"python文档读写方法 2022-07-14 · bobby 一、文档读写实用方法 1、readline()函数 解释：此函数读取文件默认打印第一行，后面可以接参数打印字符个数 with open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readline() print rows 2、readlines()函数 file.readline()[index] 解释：此函数把文件作列表全部读取出来，可通过for循环获取每一行的值 with open(p, \u0026#39;rt\u0026#39;) as f: rows = f.readlines() for i,","title":""},{"content":"Python离线安装包地址 2022-06-15 · bobby\n1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/ ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%9C%B0%E5%9D%80/","summary":"Python离线安装包地址 2022-06-15 · bobby 1、py官方库 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 2、pypc网站 https://pypi.org/project/ 3、py各大镜像库 https://pypi.tuna.tsinghua.edu.cn/simple http://mirrors.aliyun.com/pypi/simple/ http://pypi.douban.com/simple/ http://pypi.hustunique.com/ http://pypi.sdutlinux.org/ http://pypi.mirrors.ustc.edu.cn/","title":""},{"content":"Python集合详解 2022-07-27 · bobby\n用于关系运算的集合体，由于集合内的元素无序且集合元素不可重复，因此集合可以去重，但是去重后的集合会打乱原来元素的顺序\n一、集合常用方法 1、长度len c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print len(c) #4 2、成员运算in和not in c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print \u0026#34;c\u0026#34; in c #True print \u0026#34;b\u0026#34; in c #False 3、|并集、union #两个集合去重复拼接 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c|b print c.union(b) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) #set([\u0026#39;nike\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) 4、\u0026amp;交集、intersection #两个集合之间存在相同的值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c\u0026amp;b print c.intersection(b) #set([\u0026#39;nike\u0026#39;]) #set([\u0026#39;nike\u0026#39;]) 5、-差集、difference #打印出集合1对比集合2不同的值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c-b print b.difference(c) #set([\u0026#39;tow\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;bobby\u0026#39;]) #set([\u0026#39;four\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;three\u0026#39;]) 6、^对称差集、symmetric_difference #去除两个集合之间相同的值，然后拼接为一个集合 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c^b print b.symmetric_difference(c) #set([\u0026#39;bobby\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) #set([\u0026#39;bobby\u0026#39;, \u0026#39;tow\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;four\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;hello\u0026#39;]) 7、两集合是否相同-== #判断两个集合是否一样- c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c==b #False print c==a #True 8、父集：\u0026gt;、\u0026gt;= 、issuperset #判断集合1是否为集合2的父集，返回布尔值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c\u0026gt;=a #True print c\u0026gt;a #True print b\u0026gt;=a #False 9、子集：\u0026lt;、\u0026lt;= 、issubset #判断集合1是否为集合2的子集，返回布尔值 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} a={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print a\u0026lt;=c #True print a\u0026lt;c #True print a\u0026lt;=b #False 二、集合内置方法 1、增加元素-set.add() c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.add(\u0026#34;uu\u0026#34;) print c #set([\u0026#39;uu\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;tow\u0026#39;]) 2、增加元组-set.update(set) #填入字符串默认转化为set格式，所以重复的字符串只能加入1次 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} c.update(\u0026#34;fff\u0026#34;) print c #set([\u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;tow\u0026#39;]) 3、删除元素 #第一种-set.remove(值) c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.remove(\u0026#34;oen\u0026#34;) print c #set([\u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;tow\u0026#39;]) #第二种-set.pop(),默认最后一个 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.pop() print c #set([\u0026#39;nike\u0026#39;, \u0026#39;oen\u0026#39;, \u0026#39;tow\u0026#39;]) #第三种-set.clear(),清空所有 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} c.clear() print c #set([]) 4、移除元素-discard() #如果x在集合S中，移除该元素；如果x不在集合S中，不报错 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;,\u0026#34;aa\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;,\u0026#34;aa\u0026#34;} c.discard(\u0026#34;oen\u0026#34;) print c #set([\u0026#39;aa\u0026#39;, \u0026#39;bobby\u0026#39;, \u0026#39;nike\u0026#39;, \u0026#39;tow\u0026#39;]) 5、并集判断-isdisjoint() #如果集合S与T没有相同元素，返回True c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;,\u0026#34;aa\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;,\u0026#34;aa\u0026#34;} a={\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;} c.discard(\u0026#34;tow\u0026#34;) print c.isdisjoint(b) #False print c.isdisjoint(a) #True ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/python%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/","summary":"Python集合详解 2022-07-27 · bobby 用于关系运算的集合体，由于集合内的元素无序且集合元素不可重复，因此集合可以去重，但是去重后的集合会打乱原来元素的顺序 一、集合常用方法 1、长度len c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print len(c) #4 2、成员运算in和not in c={\u0026#34;c\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;o\u0026#34;,\u0026#34;r\u0026#34;} print \u0026#34;c\u0026#34; in c #True print \u0026#34;b\u0026#34; in c #False 3、|并集、union #两个集合去重复拼接 c={\u0026#34;oen\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;bobby\u0026#34;} b={\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;,\u0026#34;nike\u0026#34;,\u0026#34;hello\u0026#34;} print c|b print","title":""},{"content":"压测需求定制计算方法 2022-07-15 · bobby\n1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求） 总请求数 = 4.13 万请求数 = 41300 请求数 总时间：由于不知道每个请求的具体时间，我们按照普通方法，我们可以按照一周的时间进行计算，总时间 = 1天 = 1 * 24 小时 = 24 * 3600 秒 套入公式可得：TPS = 41300请求数/24*3600秒 = 0.48请求数/秒 结论：按照普通计算方法，我们在测试环境对相同的系统进行性能测试时，每秒能够发送0.48请求就可以满足线上的需要 2、二八原则计算方法 二八原则就是指80%的请求在20%的时间内完成 计算公式 ： TPS = 总请求数 80% / (总时间20%) **按照公式进行计算：TPS = 41300 * 0.8请求数 / 24*3600*0.2秒 = 1.91 请求数/秒 **结论：**按照二八原则计算，在测试环境我们的TPS只要能达到1.91请求数每秒就能满足线上需要。二八原则的估算结果会比平均值的计算方法更能满足用户需求。 3、照业务数据进行计算 计算模拟用户正常业务操作（稳定性测试）的并发量： 根据这些数据统计图，可以得出结论： 大部分订单在8点-24点之间，因此系统的有效工作时长为16个小时 从订单数量统计，8-24点之间的订单占一天总订单的98%左右（40474个） 结合二八原则计算公式 ： TPS = 总请求数 80% / (总时间20%) 需要在测试环境模拟用户正常业务操作（稳定性测试）的并发量为：TPS = 40474 * 0.8请求数 / 16*3600*0.2秒 = 2.81 请求数/秒 计算模拟用户峰值业务操作（压力测试）的并发量： 根据这些数据统计图，可以得出结论： 订单最高峰在在21点-22点之间，一小时的订单总数大约为8853个 计算压力测试的并发数：TPS = 峰值请求数/峰值时间 * 系数 需要在测试环境模拟用户峰值业务操作（压力测试）的并发量为： TPS = 8853 请求数 / 3600秒 * 3（系数） = 7.38 请求数/秒 ","permalink":"https://bobby-sheng.github.io/BobbySheng/en/posts/blog/%E5%8E%8B%E6%B5%8B%E9%9C%80%E6%B1%82%E5%AE%9A%E5%88%B6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","summary":"压测需求定制计算方法 2022-07-15 · bobby 1、普通计算方法 计算公式：TPS= 总请求数 / 总时间 按照需求所示，在2019年第32周，有4.13万的浏览量，那么总请求数，我们可以认为估算为4.13万（1次浏览都至少对应1个请求） 总请求数 = 4.13 万请求数 = 41300 请求数 总时间：由于不知道每个请求的具体时间，我们按","title":""}]